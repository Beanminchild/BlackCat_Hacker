<!DOCTYPE html><html><head><title>Black Cat Hacker</title><style>body{margin:0;overflow:hidden;background-color:#222}canvas{background-color:#728C69;display:block;margin:0 auto;position:relative;z-index:1}#startScreen{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:10}#startButton{padding:20px 40px;font-size:24px;background-color:#555;color:white;border:none;cursor:pointer}#scoreboard{position:absolute;top:20px;right:20px;font-size:24px;color:white;z-index:20}#gitScoreBar{z-index:21;position:relative;}#gitAdditions,#gitDeletions,#gitCube{z-index:22;position:relative;}</style></head><body><div id="workday-message" style="display:none;position:absolute;top:50px;left:50%;transform:translateX(-50%);font-size:2.5em;color:#fff;background:rgba(0,0,0,0.85);padding:20px 40px;border-radius:12px;z-index:2000">work day over</div><div id="startScreen" style="display:flex;flex-direction:column;justify-content:center;align-items:center;position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgb(0,0,0);z-index:10"><h1 style="color:white;font-family:sans-serif;font-size:3em;margin-bottom:24px">B|ackC4t_H@cker</h1><div id="gitGraphGrid" style="display:grid;grid-template-columns:repeat(4,32px);grid-template-rows:repeat(2,32px);gap:12px;margin-bottom:24px;justify-content:center;align-items:center;width:max-content;margin-left:auto;margin-right:auto"><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:1;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:2;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:3;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:4;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:1;grid-row:2"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:2;grid-row:2"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:3;grid-row:2"></canvas></div><div id="fedoraOption" style="margin-bottom: 20px; display: none; align-items: center;"><input type="checkbox" id="fedoraCheckbox" style="margin-right: 10px;"><label for="fedoraCheckbox" style="color: white; font-family: sans-serif;">Script wears Fedora</label></div><button id="startButton" style="margin:0 auto 0 auto;display:block">Start Game</button><div id="reportScreen" style="display:none;margin-top:24px;color:white;font-family:sans-serif;background:#222;border-radius:12px;padding:24px 32px;box-shadow:0 4px 32px #000a;text-align:center"></div></div><div id="gameOverScreen" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.92);z-index:100;color:white;justify-content:center;align-items:center;flex-direction:column;font-family:sans-serif"><div style="background:#222;padding:32px 48px;border-radius:16px;box-shadow:0 4px 32px #000a;display:flex;flex-direction:column;align-items:center;gap:24px"><h1 id="gameOverMessage" style="margin:0;font-size:2.5em"></h1><div id="finalScores" style="font-size:1.3em"></div><canvas id="gitGraph" width="24" height="24" style="margin-top:12px;border-radius:4px;background:#181818;border:2px solid #222;box-shadow:0 2px 6px #0004"></canvas><button id="restartButton" style="margin-top:18px;font-size:1.1em;padding:10px 32px;border-radius:8px;border:none;background:#2ea043;color:white;cursor:pointer">Next Day</button></div></div><div id="scoreboard"><div id="gitScoreBar" style="display:flex;align-items:center;gap:12px"><span style="background:#2ea043;color:white;border-radius:4px 0 0 4px;padding:4px 10px;font-family:monospace;font-size:20px;display:flex;align-items:center">+<span id="gitAdditions">0</span></span><span style="background:#f85149;color:white;border-radius:0 4px 4px 0;padding:4px 10px;font-family:monospace;font-size:20px;display:flex;align-items:center;opacity:0.9">-<span id="gitDeletions">0</span></span><span id="gitCube" style="width:24px;height:24px;margin-left:8px;border-radius:4px;background:#888;display:inline-block;border:2px solid #222;box-shadow:0 2px 6px #0004"></span></div></div><canvas id="gameCanvas"></canvas></body></html>
<Script>
    let catWearsFedora = false;
        let round = 1;
        let timerInterval = null;
        let baseTime = 100 + Math.random() * 20;
        baseTime = Math.floor(baseTime);
        let currentTime = baseTime;
        function formatTime(secs) {
            const m = Math.floor(secs / 60).toString().padStart(2, '0');
            const s = (secs % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function endRound() {
            clearInterval(timerInterval);
            gameStarted = false;
            gameOverScreen.style.display = 'flex';
            gameOverScreen.setAttribute('data-reason', 'timeout');
            document.getElementById('gameOverMessage').textContent = 'work day over';
             document.getElementById('restartButton').innerHTML = 'Next Day';
            finalScores.innerHTML = `<span style='color:#2ea043;'>+${score} additions</span> &nbsp; <span style='color:#f85149;'>-${deletionsScore} deletions</span>`;
            drawGitGraph();
            if (gitGraphResults.length < maxGames) {
                gitGraphResults.push({ score, deletions: deletionsScore });
            }
            uGGG();
        }
        function startTimer() {
            timerInterval = setInterval(() => {
                currentTime--;
                if (currentTime <= 0) {
                    endRound();
                }
            }, 1000);
        }

        function nextRound() {
            round++;
            startTimer();
        }
        let coffeeCups = [];
        const coffeeEmoji = '\u{2615}';
        function spawnCoffeeCups() {
            coffeeCups = [];
            const numCups = 1 + Math.floor(Math.random() * 3);
            let spots = [];

            [...shelves, ...randomShelves].forEach(shelf => {
                spots.push({
                    x: shelf.x + 20 + Math.random() * (shelf.width - 40),
                    y: shelf.y - 18 + Math.random() * 4
                });
            });

            for (let i = 0; i < numCups && spots.length > 0; i++) {
                const idx = Math.floor(Math.random() * spots.length);
                const pos = spots.splice(idx, 1)[0];
                coffeeCups.push({
                    x: pos.x,
                    y: pos.y,
                    vx: 0,
                    vy: 0,
                    airborne: false,
                    alpha: 1
                });
            }
        }
        function isCatNearCup(cup) {

            const catCenterX = cat.x + cat.width / 2;
            const catCenterY = cat.y + cat.height / 2;

            const cupCenterX = cup.x + 10;
            const cupCenterY = cup.y + 10;
            return Math.abs(catCenterX - cupCenterX) < 32 && Math.abs(catCenterY - cupCenterY) < 32;
        }
        function pushCoffeeCup(cup) {
            if (cup.airborne) return;
            const catCenterX = cat.x + cat.width / 2;
            const cupCenterX = cup.x + 10;
            let dir = Math.sign(cupCenterX - catCenterX) || 1;
            cup.vx = dir * (2.5 + Math.random() * 1.5);
            cup.vy = -4.5 - Math.random() * 1.5;
            cup.airborne = true;
            if (stealthState === 'hands' && handsProgress === 1) {
                stealthState = 'handsChase';
                handsChaseActive = false;
            }
        }
        let gitGraphResults = [];
        const maxGames = 7;
        function getRank(total) {
            if (total >= 7000) return 'B|ackc4t_h@cker';
            if (total >= 5000) return 'Grey Cat Hacker';
            if (total >= 3500) return 'Pawtonista';
            if (total >= 2000) return 'Script kitty';
            if (total >= 1000) return 'Copy-pasta cat';
            return 'Emmie';
        }
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;
        let stealthState = 'idle';
        let scrubStainTimer = 0;
        let scrubStainProgress = 0;
        let scrubStainAlpha = 0;
        let scrubStainActive = false;
        let scrubFootstepsProgress = 0;
        let scrubStainX = null;
        let scrubStainY = null;
        let stealthTimer = 0;
        let nextStealthEvent = Date.now() + 3000 + Math.random() * 5000
        let doorOpenProgress = 0;
        let footprintsProgress = 0;
        let handsProgress = 0;
        let handsHoldTimer = 0;
        let fSBP = 0;
        let doorCloseProgress = 0;
        let lastStealthFrame = Date.now();
        let meowCount = 0;
        let meowTarget = 0;
        let chaseSuccessCount = 0;
        let chaseSuccessThreshold = 1 + Math.floor(Math.random() * 3);
        let handsChaseTimer = 0;
        let handsChaseStart = 0;
        let handsChasePos = { x: 0, y: 0 };
        let handsChaseActive = false;
        let handsChaseSpeed = 2.0;
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const gitGraphGrid = document.getElementById('gitGraphGrid');
        const reportScreen = document.getElementById('reportScreen');
        const scoreboard = document.getElementById('scoreboard');

        const aMajorScale = [440, 494, 554, 587, 659, 740, 831, 880];
        let audioCtx = null;

        function playSoundEffect({
            type = 'default',
            pitch = 440,
            duration = 0.18,
            volume = 0.18,
            scale = aMajorScale,
            randomize = true
        } = {}) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();


            let freq = pitch;
            if (scale && scale.length) {

                freq = scale.reduce((prev, curr) => Math.abs(curr - pitch) < Math.abs(prev - pitch) ? curr : prev);

                if (randomize) {
                    freq = scale[Math.floor(Math.random() * scale.length)];
                }
            }
            if (randomize) {
                duration += (Math.random() - 0.5) * 0.05;
                volume += (Math.random() - 0.5) * 0.04;
            }

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();


            osc.type = (type === 'meow') ? 'triangle' :
               (type === 'scrub') ? 'square' :
               (type === 'alert') ? 'sawtooth' :
               'sine';
            osc.frequency.value = freq;
            gain.gain.value = Math.max(0.01, volume);

            osc.connect(gain).connect(audioCtx.destination);


            gain.gain.setValueAtTime(gain.gain.value, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);

            osc.start();
            osc.stop(audioCtx.currentTime + duration);

            osc.onended = () => osc.disconnect();
        }

    function playGOP() {
        const notes = [
            { pitch: 349.23, duration: 0.38 },
            { pitch: 392.00, duration: 0.38 },
            { pitch: 415.30, duration: 0.38 },
            { pitch: 392.00, duration: 0.38 },
            { pitch: 349.23, duration: 0.38 },
            { pitch: 311.13, duration: 0.48, delay: 0.7 },
            { pitch: 293.66, duration: 0.48, delay: 0.5 }
        ];

        let time = 0;
        notes.forEach(note => {
            time += (note.delay || 0) + note.duration + 0.12;
            setTimeout(() => {
                playSoundEffect({
                    type: 'meow',
                    pitch: note.pitch,
                    duration: note.duration,
                    volume: 0.19,
                    randomize: false,
                    scale: null
                });
            }, time * 1000);
        });
    }
       function pBS() {
           [174.61, 220, 261.63].forEach(pitch => {
               playSoundEffect({
                   type: 'meow',
                   pitch,
                   duration: 1.2,
                   volume: 0.22,
                   randomize: false,
                   scale: null
               });
           });
       }
            function uGGG() {
                const squares = gitGraphGrid.querySelectorAll('.gitGraphSquare');
                for (let i = 0; i < squares.length; i++) {
                    const ctx = squares[i].getContext('2d');
                    ctx.clearRect(0, 0, 32, 32);
                    if (gitGraphResults[i]) {
                        const net = Math.max(0, gitGraphResults[i].score - gitGraphResults[i].deletions);
                        const maxScore = 1000;
                        const percent = Math.min(net / maxScore, 1);
                        function lerp(a, b, t) { return a + (b - a) * t; }
                        function hexToRgb(hex) {
                            hex = hex.replace('#', '');
                            if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                            const num = parseInt(hex, 16);
                            return [num >> 16, (num >> 8) & 0xff, num & 0xff];
                        }
                        function rgbToHex([r, g, b]) {
                            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                        }
                        const grey = hexToRgb('#888');
                        const green = hexToRgb('#2ea043');
                        const color = [
                            Math.round(lerp(grey[0], green[0], percent)),
                            Math.round(lerp(grey[1], green[1], percent)),
                            Math.round(lerp(grey[2], green[2], percent))
                        ];
                        ctx.fillStyle = rgbToHex(color);
                        ctx.fillRect(0, 0, 32, 32);
                        ctx.strokeStyle = '#2ea043';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(1, 1, 30, 30);
                    } else {

                        ctx.fillStyle = '#181818';
                        ctx.fillRect(0, 0, 32, 32);
                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(1, 1, 30, 30);
                    }
                }
            }
            let shelves = [];
            let randomShelves = [];


            const cat = {
                x: 50,
                y: 500,
                width: 20,
                height: 20,
                speed: 5,
                velocityY: 0,
                isJumping: false,
                color: 'black'
            };
            const doorX = 30;
            const doorY = 333;
            const doorW = 60;
            const doorH = 140;
            const deskWidth = 120;
            const deskHeight = 60;
            const desk = {
                x: canvas.width - deskWidth,
                y: canvas.height - deskHeight - 20,
            };

            const monitor = {
                x: 680,
                y: 300,
                width: 100,
                height: 100,
                label: 'Monitor'
            };
        let gameStarted = false;
        let codeMode = false;
        let score = 0;
        let codeParticles = [];
        const gitAdditions = document.getElementById('gitAdditions');
        const gitDeletions = document.getElementById('gitDeletions');
        const gitCube = document.getElementById('gitCube');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScores = document.getElementById('finalScores');
        const gitGraph = document.getElementById('gitGraph');
        const restartButton = document.getElementById('restartButton');
        let deletionsScore = 0;
        let lastHandsSecond = null;
        let additionsHistory = [];
        function aD(points) {
            let startScore = deletionsScore;
            let endScore = deletionsScore + points;
            const animationDuration = 20;
            const startTime = performance.now();
            function updateScore(currentTime) {
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / animationDuration, 1);
                const animatedScore = Math.floor(startScore + (endScore - startScore) * progress);
                gitDeletions.textContent = animatedScore;
                if (progress < 1) {
                    requestAnimationFrame(updateScore);
                } else {
                    deletionsScore = endScore;
                    gitDeletions.textContent = deletionsScore;
                }
            }

            requestAnimationFrame(updateScore);
        }

            function isCatNearMonitor() {
                const catCenterX = cat.x + cat.width / 2;
                const catCenterY = cat.y + cat.height / 2;
                const monitorCenterX = monitor.x + monitor.width / 2;
                const monitorCenterY = monitor.y + monitor.height/2
                if (Math.abs(catCenterX - monitorCenterX) < 40 && Math.abs(catCenterY - monitorCenterY) < 30) return true;
            }
            shelves=[{x:25,y:315,width:65,height:20,color:'transparent'},{x:200,y:400,width:100,height:20,color:'#4b371C'},{x:325,y:290,width:150,height:20,color:'#4b371C'},{x:670,y:380,width:150,height:20,color:'#4b371C'}];
            function generateCodeParticle(score) {

                const codeSnippets=[{text:"console.log(meow')",consoleColor:'white',logColor:'green',meowColor:'lightblue'},{text:"cat.jump()",consoleColor:'white',logColor:'orange',meowColor:'white'},{text:"if ( cat.Slep) { slepMore() }",consoleColor:'white',logColor:'yellow',meowColor:'white'},{text:"error ('too many belly rubs)",consoleColor:'white',logColor:'red',meowColor:'white'},{text:"function headscratch() { return 'purr' }",consoleColor:'white',logColor:'lime',meowColor:'white'}];

                const snippet = codeSnippets[Math.floor(Math.random() * codeSnippets.length)];

                codeParticles.push({
                    x: monitor.x - 500,
                    y: monitor.y + monitor.height / 2,
                    text: snippet.text,
                    consoleColor: snippet.consoleColor,
                    logColor: snippet.logColor,
                    meowColor: snippet.meowColor,
                    size: 12,
                    speedX: Math.random() * 2 - 1,
                    speedY: Math.random() * -2 - 1,
                    targetX: canvas.width - 25,
                    targetY: 50,
                    alpha: 1
                });
            }
        function triggerScrubStain(x, y) {
            if (stealthState === 'hands' || stealthState === 'handsChase') {
                handsChaseActive = false;
            }
            stealthState = 'scrubStain';
            scrubStainTimer = 0;
            scrubStainProgress = 0;
            scrubStainAlpha = 1;
            scrubStainActive = true;
            scrubStainX = (typeof x === 'number') ? x : canvas.width / 2;
            scrubStainY = (typeof y === 'number') ? y : (canvas.height / 2 + 80);
        }

        function endHandsMonitorAndTriggerWalkBack() {
            stealthState = 'footstepsBack';
            fSBP = 0;
            lastHandsSecond = null;
            handsHoldTimer = 0;
        }

        function spawnRandomShelves() {
            randomShelves = [];
            const numShelves = Math.floor(Math.random() * 3);
            for (let i = 0; i < numShelves; i++) {
                const x = 80 + Math.random() * 520;
                const y = 180 + Math.random() * 30;
                const width = 60 + Math.random() * 40;
                const height = 20;
                randomShelves.push({ x, y, width, height, color: '#7a5c3c' });
            }
        }
        function update() {
                let cupsToRemove = [];
                coffeeCups.forEach((cup, i) => {
                    if (cup.airborne) {
                        cup.x += cup.vx;
                        cup.y += cup.vy;
                        const cupWidth = 20;
                        if (cup.x < 0) {
                            playSoundEffect({ type: 'scrub', pitch: 554, duration: 0.2 });
                            cup.x = 0;
                            cup.vx *= -1;
                        } else if (cup.x > canvas.width - cupWidth) {
                            cup.x = canvas.width - cupWidth;
                            cup.vx *= -1;
                        }
                        cup.vy += 0.35;
                        if (cup.y + 20 > desk.y && cup.vy > 0) {
                            cup.y = desk.y - 20;
                            playSoundEffect({ type: 'scrub', pitch: 554, duration: 0.2 });
                            if (!scrubStainActive) {
                                triggerScrubStain(cup.x + 10, desk.y - 10);
                            }
                            cup.vy *= -0.35;
                            cup.vx *= 0.6;
                            if (Math.abs(cup.vy) < 1.2) {
                                cup.vy = 0;
                                cup.airborne = false;
                                cupsToRemove.push(i);
                            }
                        }
                        [shelves, randomShelves].flat().forEach(shelf => {
                            if (
                                cup.x + 20 > shelf.x &&
                                cup.x < shelf.x + shelf.width &&
                                cup.y + 20 > shelf.y &&
                                cup.y < shelf.y + shelf.height &&
                                cup.vy > 0
                            ) {
                                playSoundEffect({ type: 'scrub', pitch: 554, duration: 0.2 });
                                cup.y = shelf.y - 20;
                                cup.vy *= -0.35;
                                cup.vx *= 0.6;
                                if (Math.abs(cup.vy) < 1.2) {
                                    cup.vy = 0;
                                    cup.airborne = false;
                                }
                            }
                        });
                    }
                });
                if (cupsToRemove.length > 0) {
                    cupsToRemove.sort((a, b) => b - a).forEach(idx => coffeeCups.splice(idx, 1));
                }

                if (!gameStarted) return;

                if (stealthState === 'scrubStain') {
                    scrubStainTimer++;
                    if (scrubStainTimer < 120) {
                        scrubStainProgress = scrubStainTimer / 120;
                        scrubStainAlpha = 1 - (scrubStainTimer / 120);
                    } else if (scrubStainTimer < 270)
                    {
                        scrubStainProgress = 1;
                        scrubFootstepsProgress = (scrubStainTimer-120)/150;
                        scrubStainAlpha = 0;
                    } else if (scrubStainTimer < 330)
                    {
                        scrubStainAlpha = 0;
                    } else {
                        scrubStainActive = false;
                        scrubFootstepsProgress = 0;
                        stealthState = 'idle';
                        nextStealthEvent = Date.now() + 3000 + Math.random() * 4000;
                    }
                }
                const now = Date.now();
                if (stealthState === 'handsChase') {
                    if (!handsChaseActive) {
                        handsChaseActive = true;
                        handsChaseStart = now;
                        handsChaseTimer = 0;
                        handsChasePos.x = monitor.x + monitor.width / 2;
                        handsChasePos.y = monitor.y + monitor.height - 10;
                    }
                    const catCenterX = cat.x + cat.width / 2;
                    const catCenterY = cat.y + cat.height / 2;
                    const dx = catCenterX - handsChasePos.x;
                    const dy = catCenterY - handsChasePos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        handsChasePos.x += (dx / dist) * handsChaseSpeed;
                        handsChasePos.y += (dy / dist) * handsChaseSpeed;
                    }
                    if (
                        handsChasePos.x > cat.x - 18 &&
                        handsChasePos.x < cat.x + cat.width + 18 &&
                        handsChasePos.y > cat.y - 16 &&
                        handsChasePos.y < cat.y + cat.height + 16
                    ) {
                        endGame();
                        return;
                    }
                    handsChaseTimer = now - handsChaseStart;
                    if (handsChaseTimer > 7000) {
                        handsChaseActive = false;
                        chaseSuccessCount++;
                        meowCount = 0;
                        meowTarget = 0;
                        if (chaseSuccessCount >= chaseSuccessThreshold) {
                            endHandsMonitorAndTriggerWalkBack();
                            chaseSuccessCount = 0;
                            chaseSuccessThreshold = 1 + Math.floor(Math.random() * 3);
                        } else {
                            stealthState = 'hands';
                            handsProgress = 1;
                        }
                    }
                } else {
                    if (now > nextStealthEvent && stealthState === 'idle') {
                        chaseSuccessCount = 0;
                        chaseSuccessThreshold = 1 + Math.floor(Math.random() * 3);
                        stealthState = 'doorOpening';
                        doorOpenProgress = 0;
                        footprintsProgress = 0;
                        handsProgress = 0;

                        fSBP = 0;
                        doorCloseProgress = 0;
                    }
                    if (stealthState === 'doorOpening') {
                        doorOpenProgress += 0.02;
                        if (doorOpenProgress >= 1) {
                            doorOpenProgress = 1;
                            stealthState = 'footprints';
                        }
                    } else if (stealthState === 'footprints') {
                        footprintsProgress += 0.008;
                        if (footprintsProgress >= 1) {
                            footprintsProgress = 1;
                            stealthState = 'hands';
                            handsHoldTimer = 0;
                            lastHandsSecond = null;
                        }
                    } else if (stealthState === 'hands') {
                        if (handsProgress < 1) {
                            handsProgress += 0.02;
                            if (handsProgress > 1) handsProgress = 1;
                        } else {
                            handsHoldTimer += 16;
                            let handsSeconds = Math.floor(handsHoldTimer / 1000);
                            if (lastHandsSecond !== handsSeconds) {
                                lastHandsSecond = handsSeconds;
                                aD(5);
                                playSoundEffect({ type: 'alert', pitch: 220 + Math.random() * 100, duration: 0.12, volume: 0.15 });
                            }
                            if (isCatNearMonitor()) {
                                endGame();
                                return;
                            }
                            if (handsHoldTimer >= 30000) {
                                stealthState = 'footstepsBack';
                                fSBP = 0;
                                lastHandsSecond = null;
                            }
                        }
                    } else if (stealthState === 'footstepsBack') {
                        fSBP += 0.012;
                        if (fSBP >= 1) {
                            fSBP = 1;
                            stealthState = 'doorClosing';
                            doorCloseProgress = 0;
                        }
                    } else if (stealthState === 'doorClosing') {
                        doorCloseProgress += 0.02;
                        if (doorCloseProgress >= 1) {
                            doorCloseProgress = 1;
                            stealthState = 'idle';
                            nextStealthEvent = Date.now() + 4000 + Math.random() * 3000;
                        }
                    }
                }
                if (isCatNearMonitor()) {
                    codeMode = true;
                } else {
                    codeMode = false;
                }
                cat.velocityY += 0.5;
                cat.y += cat.velocityY;
                let onGround = false;
                if (cat.y + cat.height > desk.y) {
                    cat.y = desk.y - cat.height;
                    cat.velocityY = 0;
                    cat.isJumping = false;
                    onGround = true;
                }
                shelves.concat(randomShelves).forEach(shelf => {
                    if (cat.x < shelf.x + shelf.width &&
                        cat.x + cat.width > shelf.x &&
                        cat.y + cat.height > shelf.y &&
                        cat.y < shelf.y + shelf.height &&
                        cat.velocityY >= 0) {
                        cat.y = shelf.y - cat.height;
                        cat.velocityY = 0;
                        cat.isJumping = false;
                        onGround = true;
                    }
                });
                if (keys['ArrowLeft']) {
                    cat.x -= cat.speed;
                }
                if (keys['ArrowRight']) {
                    cat.x += cat.speed;
                }
                if (cat.x < 0) {
                    cat.x = 0;
                }
                if (cat.x + cat.width > canvas.width) {
                    cat.x = canvas.width - cat.width;
                }
                codeParticles.forEach((particle, index) => {
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    if (particle.isMeow) {
                        const dx = (particle.targetX - particle.x) * 0.04;
                        const dy = (particle.targetY - particle.y) * 0.04;
                        particle.x += dx;
                        particle.y += dy;
                        particle.alpha -= 0.008;
                        if (particle.alpha <= 0.01) {
                            codeParticles.splice(index, 1);
                        }
                    } else {
                        const dx = particle.targetX - particle.x;
                        const dy = particle.targetY - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 10) {
                            codeParticles.splice(index, 1);

                        }
                        particle.alpha -= 0.01;
                        if (particle.alpha <= 0) {
                            codeParticles.splice(index, 1);
                        }
                    }
                });
                if (gameStarted && additionsHistory.length < 32) {
                    additionsHistory.push(score);
                }
            }
        function drawScrubStain() {
            if (!(scrubStainActive && scrubStainX !== null && scrubStainY !== null)) return;
            const x = scrubStainX, y = scrubStainY;
            ctx.save();
            ctx.globalAlpha = scrubStainAlpha;
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(x, y, 38 + Math.sin(scrubStainTimer / 6) * 2, 0, 2 * Math.PI);
            ctx.fillStyle = '#6b3e26';
            ctx.fill();
            ctx.globalAlpha = Math.min(1, scrubStainAlpha + 0.2);
            ctx.beginPath();
            ctx.arc(x + 10, y - 8, 12, 0, 2 * Math.PI);
            ctx.arc(x - 14, y + 6, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#8d5c3c';
            ctx.fill();
            ctx.restore();

            if (scrubStainTimer < 120) {
                drawGameHand(x - 28, y - 32, 1, 0.9);
                const angle = (scrubStainTimer / 18) * 2 * Math.PI, r = 22;
                drawGameHand(x + Math.cos(angle) * r + 18, y + Math.sin(angle) * r - 18, 1, 1);
            } else if (scrubStainTimer < 2440) {
                const t = scrubFootstepsProgress, steps = 8;
                const sx = x, sy = y + 18, ex = doorX + doorW / 2, ey = doorY + doorH - 18;
                for (let i = 0; i < steps; i++) {
                    const stepT = i / (steps - 1);
                    const fx = sx + (ex - sx) * stepT, fy = sy + (ey - sy) * stepT;
                    ctx.save();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = Math.max(0, Math.min(1, (t - stepT) * 2));
                    ctx.beginPath();
                    ctx.ellipse(fx, fy, 8, 4, (i % 2 === 0 ? 0 : Math.PI / 8), 0, 2 * Math.PI);
                    ctx.fillStyle = '#444';
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        function drawGameHand(x, y, scale=1, alpha=1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.beginPath();
            ctx.ellipse(0, 0, 22, 16, Math.PI/10, 0, 2*Math.PI);
            ctx.fillStyle = '#f3e2c7';
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-16, 2, 7, 12, -Math.PI/3, 0, 2*Math.PI);
            ctx.fillStyle = '#e2c7a0';
            ctx.fill();
            for (let i = -1.2; i <= 1.2; i += 0.8) {
                ctx.beginPath();
                ctx.ellipse(10 + i*7, -10, 6, 14, Math.PI/8 + i*0.1, 0, 2*Math.PI);
                ctx.fillStyle = '#f3e2c7';
                ctx.fill();
            }
            ctx.restore();
        }

        function draw() {
                let resetCount = 0;
                while (resetCount < 100) {
                    try {
                        ctx.restore();
                        resetCount++;
                    } catch (e) {
                        break;
                    }
                }
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#728C69';
                const wallBottomY = desk.y - 60;
                ctx.fillRect(0, 0, canvas.width, wallBottomY);
                const floorboardY = wallBottomY;
                ctx.fillStyle = '#bcae99';
                ctx.fillRect(0, floorboardY, canvas.width, canvas.height - floorboardY);
                ctx.save();
                ctx.shadowColor = '#222a';
                ctx.shadowBlur = 20;
                ctx.fillStyle = '#6b4a2b';
                ctx.fillRect(0, floorboardY - 8, canvas.width, 16);
                ctx.restore();
                updateGitCubeColor();
                if (scrubStainActive) {
                    drawScrubStain();
                }
                ctx.save();
                ctx.globalAlpha = 0.85;
                ctx.fillStyle = '#4b371c';
                ctx.beginPath();
                ctx.fill();
                ctx.restore();
                const windowX = canvas.width / 2 - 70;
                const windowY = 220;
                let windowSunProgress = 0;
                if (gameStarted && baseTime > 0) {
                    windowSunProgress = 1 - (currentTime / baseTime);
                    if (windowSunProgress < 0) windowSunProgress = 0;
                    if (windowSunProgress > 1) windowSunProgress = 1;
                } else {
                    windowSunProgress = 0;
                }
                function lerpColor(a, b, t) {
                    const ah = parseInt(a.replace('#',''),16), bh = parseInt(b.replace('#',''),16);
                    const ar = (ah>>16)&0xff, ag = (ah>>8)&0xff, ab = ah&0xff;
                    const br = (bh>>16)&0xff, bg = (bh>>8)&0xff, bb = bh&0xff;
                    return '#' + [
                        Math.round(ar + (br-ar)*t).toString(16).padStart(2,'0'),
                        Math.round(ag + (bg-ag)*t).toString(16).padStart(2,'0'),
                        Math.round(ab + (bb-ab)*t).toString(16).padStart(2,'0')
                    ].join('');
                }
                let skyColor;
                if (windowSunProgress < 0.5) {
                    skyColor = lerpColor('#7ecfff', '#ffb347', windowSunProgress*2);
                } else {
                    skyColor = lerpColor('#ffb347', '#6a3fa0', (windowSunProgress-0.5)*2);
                }
                ctx.save();
                ctx.beginPath();
                ctx.rect(windowX, windowY, 140, 80);
                ctx.closePath();
                ctx.clip();
                let windowGrad = ctx.createLinearGradient(windowX, windowY, windowX, windowY+80);
                windowGrad.addColorStop(0, skyColor);
                windowGrad.addColorStop(1, '#fff');
                ctx.fillStyle = windowGrad;
                ctx.fillRect(windowX, windowY, 140, 80);

                if (!draw.clouds) {
                    draw.clouds = [];
                    for (let i=0; i<3; i++) {
                        draw.clouds.push({
                            x: windowX + Math.random()*140,
                            y: windowY + 10 + Math.random()*50,
                            speed: 0.15 + Math.random()*0.12,
                            size: 18 + Math.random()*12,
                            offset: Math.random()*1000
                        });
                    }
                }
                for (let i=0; i<draw.clouds.length; i++) {
                    let c = draw.clouds[i];
                    if (gameStarted) {
                        c.x += c.speed;
                        if (c.x > windowX+140+30) {
                            c.x = windowX-40;
                            c.y = windowY + 10 + Math.random()*50;
                            c.size = 18 + Math.random()*12;
                            c.speed = 0.15 + Math.random() * 0.12;
                        }
                    }

                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(c.x, c.y, c.size, c.size*0.6, 0, 0, Math.PI*2);
                    ctx.ellipse(c.x+0.6*c.size, c.y+2, c.size*0.7, c.size*0.4, 0, 0, Math.PI*2);
                    ctx.ellipse(c.x-0.7*c.size, c.y+3, c.size*0.5, c.size*0.3, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
                ctx.restore();
                let sunProgress = 0;
                if (gameStarted && baseTime > 0) {
                    sunProgress = 1 - (currentTime / baseTime);
                    if (sunProgress < 0) sunProgress = 0;
                    if (sunProgress > 1) sunProgress = 1;
                } else {
                    sunProgress = 0;
                }
                const sunStart = { x: windowX + 20, y: windowY + 20 };
                const sunEnd = { x: windowX + 120, y: windowY + 70 };
                const sunX = sunStart.x + (sunEnd.x - sunStart.x) * windowSunProgress;
                const sunY = sunStart.y + (sunEnd.y - sunStart.y) * windowSunProgress;
                ctx.save();
                ctx.globalAlpha = 0.85;
                ctx.beginPath();
                ctx.arc(sunX, sunY, 18, 0, 2 * Math.PI);
                ctx.fillStyle = 'orange';
                ctx.shadowColor = 'yellow';
                ctx.shadowBlur = 24;
                ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.shadowColor = '#2226';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
                ctx.globalAlpha = 0.55;
                ctx.fillStyle = '#e0f7fa';
                ctx.fillRect(windowX, windowY, 140, 80);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
                ctx.strokeStyle = '#b0c4de';
                ctx.lineWidth = 6;
                ctx.strokeRect(windowX, windowY, 140, 80);
                ctx.strokeStyle = '#b0c4de';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(windowX + 70, windowY);
                ctx.lineTo(windowX + 70, windowY + 80);
                ctx.moveTo(windowX, windowY + 40);
                ctx.lineTo(windowX + 140, windowY + 40);
                ctx.stroke();
                ctx.restore();
                ctx.save();
                ctx.shadowColor = '#222a';
                ctx.shadowBlur = 18;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 8;
                let doorOpen = 0;
                if (
                    stealthState === 'doorOpening' ||
                    stealthState === 'footprints' ||
                    stealthState === 'hands' ||
                    stealthState === 'handsWait' ||
                    stealthState === 'footstepsBack' ||
                    (stealthState === 'scrubStain' && scrubStainTimer < 270)
                ) {
                    doorOpen = doorOpenProgress;
                } else if (stealthState === 'doorClosing' || (stealthState === 'scrubStain' && scrubStainTimer >= 270 && scrubStainTimer < 330)) {
                    let t = (stealthState === 'scrubStain') ? (scrubStainTimer-270)/60 : doorCloseProgress;
                    doorOpen = 1 - t;
                } else {
                    doorOpen = 0;
                }
    const doorW = 60, doorH = 135;
    const hingeLeft = true;
    const hingeX = hingeLeft ? doorX : doorX + doorW;
    const hingeY = doorY + doorH / 2;
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
    const t = Math.max(0, Math.min(1, doorOpen));
    const eased = easeOutCubic(t);
    const maxAngle = Math.PI / 2 * 0.98;
    const angle = (hingeLeft ? -1 : 1) * maxAngle * eased;
    const thickness = 12;
    const depthScale = 0.6;
    const skew = 0.6;
    if (t > 0) {
            ctx.save();
            ctx.fillStyle = 'black';
            ctx.fillRect(doorX, doorY, doorW, doorH);
            ctx.restore();
        ctx.save();
        ctx.translate(hingeX, hingeY);
        const faceScaleX = 1 - Math.abs(Math.sin(angle)) * depthScale;
        ctx.save();
        ctx.scale(faceScaleX, 1);
        ctx.fillStyle = '#5a3c1a';
        ctx.fillRect(0, -doorH/2, doorW, doorH);
        ctx.strokeStyle = '#3a220a';
        ctx.lineWidth = 5 ;
        ctx.strokeRect(0, -doorH/2, doorW, doorH);
        const knobLocalX = doorW - 8;
        const knobLocalY = 0;
        ctx.beginPath();
        ctx.arc(knobLocalX, knobLocalY, 6, 0, Math.PI * 2);
        ctx.fillStyle = '#eab676';
        ctx.fill();
        ctx.restore();
        ctx.restore();
        ctx.save();
        ctx.globalAlpha = 0.5 * eased;
        ctx.beginPath();
        ctx.moveTo(hingeX, hingeY);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    } else {
      ctx.save();
      ctx.fillStyle = '#5a3c1a';
      ctx.fillRect(doorX, doorY, doorW, doorH);
      ctx.strokeStyle = '#3a220a';
      ctx.lineWidth = 5;
      ctx.strokeRect(doorX, doorY, doorW, doorH);
      ctx.beginPath();
      ctx.arc(doorX + doorW - 8, doorY + doorH/2, 6, 0, Math.PI * 2);
      ctx.fillStyle = '#eab676';
      ctx.fill();
      ctx.restore();
    }
                ctx.save();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = desk.color;
                ctx.fillRect(desk.x, desk.y, desk.width, desk.height);
                ctx.restore();
                drawScrubStain();
                shelves.forEach(shelf => {
                    ctx.fillStyle = shelf.color;
                    ctx.fillRect(shelf.x, shelf.y, shelf.width, shelf.height);
                });
                randomShelves.forEach(shelf => {
                    ctx.fillStyle = shelf.color;
                    ctx.fillRect(shelf.x, shelf.y, shelf.width, shelf.height);
                });
                const rightShelf = shelves.reduce((a, b) => (a.x > b.x ? a : b));
                const numLegs = 2;
                const legSpacing = rightShelf.width / (numLegs + 1);
                ctx.save();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4;
                for (let i = 1; i <= numLegs; i++) {
                    const legX = rightShelf.x + i * legSpacing;
                    const legYStart = rightShelf.y + rightShelf.height;
                    const legYEnd = desk.y;
                    ctx.beginPath();
                    ctx.moveTo(legX, legYStart);
                    ctx.lineTo(legX, legYEnd);
                    ctx.stroke();
                }
                ctx.restore();

                coffeeCups.forEach(cup => {
                    ctx.save();
                    ctx.globalAlpha = cup.alpha;
                    ctx.font = '32px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(coffeeEmoji, cup.x + 16, cup.y + 28);
                    ctx.restore();
                });

                const steps = 8;
                if (stealthState === 'footprints' || stealthState === 'hands') {
                    for (let i = 0; i < steps; i++) {

                        const t = i / (steps - 1);
                        if (t > footprintsProgress) break;
                        const fx = doorX + 60 + (canvas.width - (doorX + 60)) * t;
                        const fy = doorY + 140 + (desk.y - (doorY + 70)) * t * 0.8;
                        ctx.save();
                        ctx.globalAlpha = 0.5 + 0.5 * t;
                        ctx.fillStyle = '#222';
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        ctx.beginPath();
                        ctx.ellipse(fx, fy, 10, 5, (i%2===0?0.2:-0.2), 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }
                } else if (stealthState === 'footstepsBack') {
                    const gone = Math.floor(steps * fSBP + 0.001);
                    for (let i = 0; i < steps - gone; i++) {
                        const t = i / (steps - 1);
                        const fx = doorX + 60 + (canvas.width - (doorX + 60)) * t;
                        const fy = doorY + 140 + (desk.y - (doorY + 70)) * t * 0.8;
                        ctx.save();
                        ctx.globalAlpha = 0.5 + 0.5 * t;
                        ctx.fillStyle = '#222';
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        ctx.beginPath();
                        ctx.ellipse(fx, fy, 10, 5, (i%2===0?0.2:-0.2), 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                ctx.font = `${monitor.width}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('\u{1F4BB}', monitor.x + monitor.width/2, monitor.y);

                if (stealthState === 'handsChase' && handsChaseActive) {
                    ctx.save();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    const handY = handsChasePos.y;
                    ctx.fillStyle = '#eab676';
                    ctx.beginPath();
                    ctx.ellipse(handsChasePos.x - 25, handY, 18, 16, -0.2, 0, Math.PI*2);
                    ctx.fill();
                    for (let f=0; f<4; f++) {
                        ctx.beginPath();
                        ctx.ellipse(handsChasePos.x - 35 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.beginPath();
                    ctx.ellipse(handsChasePos.x + 25, handY, 18, 16, 0.2, 0, Math.PI*2);
                    ctx.fill();
                    for (let f=0; f<4; f++) {
                        ctx.beginPath();
                        ctx.ellipse(handsChasePos.x + 15 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#f85149';
                    let chaseBarW = 120;
                    let chaseBarH = 10;
                    let chaseBarX = cat.x + cat.width/2 - chaseBarW/2;
                    let chaseBarY = cat.y - 24;
                    let chaseElapsed = Math.min(1, handsChaseTimer/7000);
                    ctx.fillRect(chaseBarX, chaseBarY, chaseBarW * (1-chaseElapsed), chaseBarH);
                    ctx.strokeStyle = '#fff';
                    ctx.strokeRect(chaseBarX, chaseBarY, chaseBarW, chaseBarH);
                    ctx.restore();

                }
                if (stealthState === 'hands') {
                    const handY = monitor.y + monitor.height - 10 + 40 * (1 - handsProgress);
                    ctx.save();
                    ctx.globalAlpha = handsProgress;
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.fillStyle = '#eab676';
                    ctx.beginPath();
                    ctx.ellipse(monitor.x + 25, handY, 18, 16, -0.2, 0, Math.PI*2);
                    ctx.fill();
                    for (let f=0; f<4; f++) {
                        ctx.beginPath();
                        ctx.ellipse(monitor.x + 15 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.beginPath();
                    ctx.ellipse(monitor.x + monitor.width - 25, handY, 18, 16, 0.2, 0, Math.PI*2);
                    ctx.fill();
                    for (let f=0; f<4; f++) {
                        ctx.beginPath();
                        ctx.ellipse(monitor.x + monitor.width - 35 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                }

                ctx.save();
                ctx.translate(cat.x + cat.width / 2, cat.y + cat.height / 2);
                if (typeof cat.lastFacing === 'undefined') cat.lastFacing = 1;
                if (keys['ArrowLeft'] && !keys['ArrowRight']) cat.lastFacing = -1;
                else if (keys['ArrowRight'] && !keys['ArrowLeft']) cat.lastFacing = 1;
                ctx.scale(cat.lastFacing, 1);
                let walkCycle = 0;
                if (cat.isJumping) {
                    walkCycle = Math.sin(Date.now() / 120) * 2;
                } else if (keys['ArrowLeft'] || keys['ArrowRight']) {
                    walkCycle = Math.sin(Date.now() / 120) * 4;
                }

                if (codeMode) {
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.ellipse(0, 8, 13, 11, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, -6, 9, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-6, -14);
                    ctx.lineTo(-3, -22);
                    ctx.lineTo(0, -10);
                    ctx.moveTo(6, -14);
                    ctx.lineTo(3, -22);
                    ctx.lineTo(0, -10);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    if (catWearsFedora) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.ellipse(0, -15, 14, 5, 0, 0, Math.PI * 2);
                        ctx.fillStyle = '#111';
                        ctx.globalAlpha = 0.95;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(-7, -15);
                        ctx.lineTo(-6, -25);
                        ctx.lineTo(-2, -27);
                        ctx.lineTo(0, -26);
                        ctx.lineTo(2, -27);
                        ctx.lineTo(6, -25);
                        ctx.lineTo(7, -15);
                        ctx.closePath();
                        ctx.fillStyle = '#111';
                        ctx.fill();

                        ctx.beginPath();
                        ctx.rect(-7, -21, 14, 3);
                        ctx.fillStyle = '#444';
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(5, -19.5);
                        ctx.lineTo(7, -19.5);
                        ctx.lineTo(6, -21);
                        ctx.closePath();
                        ctx.fillStyle = '#777';
                        ctx.fill();

                        ctx.restore();
                    }
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(0, 18);
                    ctx.bezierCurveTo(0, 32, 8, 38 + walkCycle, 0, 48 + walkCycle);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    ctx.restore();
                    let tap = Math.abs(Math.sin(Date.now() / 80));
                    let tap2 = Math.abs(Math.sin(Date.now() / 80 + 1));
                    ctx.save();
                    ctx.translate(-6, 18 + tap * 3);
                    ctx.rotate(-0.2 + tap * 0.2);
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.save();
                    ctx.translate(6, 18 + tap2 * 3);
                    ctx.rotate(0.2 - tap2 * 0.2);
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.ellipse(2, 6, 14, 7, Math.PI / 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(16, -2, 7, 8, Math.PI / 16, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(21, -4);
                    ctx.lineTo(19, -12);
                    ctx.lineTo(16, 2);
                    ctx.moveTo(11, -4);
                    ctx.lineTo(13, -12);
                    ctx.lineTo(16, 2);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    if (catWearsFedora) {
                        ctx.save();
                        let hatOffsetX = cat.lastFacing === 1 ? 16 : 16;
                        let hatOffsetY = -4;
                        ctx.translate(hatOffsetX, hatOffsetY);
                        ctx.scale(cat.lastFacing, 1);

                        ctx.beginPath();
                        ctx.ellipse(0, -7, 14, 5, Math.PI / 16, 0, Math.PI * 2);
                        ctx.fillStyle = '#111';
                        ctx.globalAlpha = 0.95;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(-7, -9);
                        ctx.lineTo(-6, -17);
                        ctx.lineTo(-2, -19);
                        ctx.lineTo(0, -18);
                        ctx.lineTo(2, -19);
                        ctx.lineTo(6, -17);
                        ctx.lineTo(7, -9);
                        ctx.closePath();
                        ctx.fillStyle = '#111';
                        ctx.fill();

                        ctx.beginPath();
                        ctx.rect(-7, -13, 14, 3);
                        ctx.fillStyle = '#444';
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(5, -11.5);
                        ctx.lineTo(7, -11.5);
                        ctx.lineTo(6, -13);
                        ctx.closePath();
                        ctx.fillStyle = '#777';
                        ctx.fill();

                        ctx.restore();
                    }

                    ctx.beginPath();
                    ctx.ellipse(19, -4, 1.5, 2, 0, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(19, -4, 0.7, 1, 0, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(23, -1, 0.7, 1, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#eab';
                    ctx.fill();
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.bezierCurveTo(-18, -18 - walkCycle, -6, -38 - walkCycle, 0, -32 - walkCycle);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    ctx.restore();
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(-2, 13);
                    ctx.lineTo(-2 + walkCycle, 22 - walkCycle);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(8, 13);
                    ctx.lineTo(8 - walkCycle, 22 + walkCycle);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
                ctx.restore();
                codeParticles.forEach(particle => {
                    ctx.save();
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.globalAlpha = particle.alpha;
                    if (particle.isMeow) {
                        ctx.font = `bold ${particle.size}px monospace`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.strokeText(particle.text, particle.x, particle.y);
                        ctx.fillStyle = '#4ec9f0';
                        ctx.fillText(particle.text, particle.x, particle.y);
                    } else {
                        ctx.font = `${particle.size}px monospace`;
                        const words = particle.text.match(/(\s+|[a-zA-Z_][a-zA-Z0-9_]*|\d+|[^\s\w])/g) || [];
                        let xOffset = 10;
                        const letterSpacing = particle.size
                        const colorMap = {
                            console: 'lightgreen',
                            log: particle.logColor,
                            meow: 'magenta', tuna: 'magenta', yarn: 'magenta', purr: 'magenta',
                            cat: 'lightblue', Food: 'lightblue', wakeUp: 'lightblue', debug: 'lightblue',
                            function: 'lightblue', return: 'lightblue', if: 'lightblue', let: 'lightblue', new: 'lightblue',
                            Slep: 'orange',
                            error: 'red'
                        };

                        words.forEach(word => {
                            let color = colorMap[word] || 'white';
                            ctx.fillStyle = color;
                            ctx.fillText(word, Math.round(particle.x + xOffset), particle.y);
                            let width = ctx.measureText(word).width;
                            xOffset += width + letterSpacing;
                        });
                    }
                    ctx.globalAlpha = 1;
                    ctx.restore();
                });
            }
            let tipTapping = false;
            let tipTapTimeout;
        document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    for (let cup of coffeeCups) {
                        if (isCatNearCup(cup) && !cup.airborne) {
                            pushCoffeeCup(cup);
                            break;
                        }
                    }
                }
                keys[e.key] = true;
                if (e.key === 'ArrowUp' && !cat.isJumping) {
                    cat.velocityY = -10;
                    cat.isJumping = true;
                }
                if (codeMode && e.key.match(/^[a-z]$/)) {
                    generateCodeParticle();
                    if (stealthState == 'handsChase'){
                    animateScore(10);
                    codeParticles.push({
                        x: cat.x + cat.width / 2,
                        y: cat.y,
                        text: '10x',
                        size: 22,
                        speedX: (Math.random() - 0.5) * 1.2,
                        speedY: -2.5 - Math.random() * 1.5,
                        targetX: cat.x + cat.width / 2 + (Math.random() - 0.5) * 40,
                        targetY: cat.y - 60 - Math.random() * 30,
                        alpha: 1,
                        isMeow: true
                    });
                    } else {
                    animateScore(1);
                    }
                    tipTapping = true;
                    clearTimeout(tipTapTimeout);
                    tipTapTimeout = setTimeout(() => { tipTapping = false; }, 120);
                }
                if (
                    stealthState === 'hands' &&
                    handsProgress === 1 &&
                    e.code === 'Space'
                ) {
                    if (!meowTarget) {
                        meowTarget = 1;
                        meowCount = 0;
                    }
                    meowCount++;
                    if (meowCount >= meowTarget) {
                        stealthState = 'handsChase';
                        handsChaseActive = false;
                    }

                    pBS();




                        codeParticles.push({
                        x: cat.x + cat.width / 2,
                        y: cat.y,
                        text: 'Aw lawd he commin!',
                        size: 22,
                        speedX: (Math.random() - 0.5) * 1.2,
                        speedY: -2.5 - Math.random() * 1.5,
                        targetX: cat.x + cat.width / 2 + (Math.random() - 0.5) * 40,
                        targetY: cat.y - 60 - Math.random() * 30,
                        alpha: 1,
                        isMeow: true
                    });
                } else if (e.code === 'Space') {

                     playSoundEffect({
                        type: 'meow',
                        pitch: bassMeowNotes[bassMeowIndex],
                        duration: .18,
                        volume: 0.18,
                        randomize: false,
                        scale: null

                                    });
                 bassMeowIndex = (bassMeowIndex + 1) % bassMeowNotes.length;

                     codeParticles.push({
                        x: cat.x + cat.width / 2,
                        y: cat.y,
                        text: 'meow',
                        size: 22,
                        speedX: (Math.random() - 0.5) * 1.2,
                        speedY: -2.5 - Math.random() * 1.5,
                        targetX: cat.x + cat.width / 2 + (Math.random() - 0.5) * 40,
                        targetY: cat.y - 60 - Math.random() * 30,
                        alpha: 1,
                        isMeow: true
                    });
                    if (!meowTarget) {
                        meowTarget = 1 + Math.floor(Math.random() * 4);
                        meowCount = 0;
                    }
                    meowCount++;
                    if (meowCount >= meowTarget) {


                        nextStealthEvent = Date.now()
                    }

                }
            });
         const cPC = [392, 294, 220, 261.63];
         let cPCI = 0;

     const bassMeowNotes = [196.00,392.00,220.00,392.00,246.94,392.00,261.62,392.00,293.66,392.00,329.62,392.00,369.98,392.00,392.00,392.00];
       let bassMeowIndex = 0;
            function animateScore(points) {
                const endScore = score + points;
                playSoundEffect({
                    type: 'score',
                    pitch: cPC[cPCI],
                    duration: 1.2,
                    volume: 0
                });
                cPCI = (cPCI + 1) % cPC.length;
                const startTime = performance.now(), duration = 1.2, startScore = score;
                (function update(current) {
                    const p = Math.min((current - startTime) / duration, 1);
                    const val = Math.floor(startScore + (endScore - startScore) * p);
                    gitAdditions.textContent = val;
                    updateGitCubeColor(val);
                    if (p < 1) requestAnimationFrame(update); else {
                        score = endScore;
                        gitAdditions.textContent = score;
                        updateGitCubeColor(score);
                    }
                })(startTime);
                if (gameStarted && additionsHistory.length < 32) additionsHistory.push(endScore);
            }

            function endGame() {
                playGOP()
                gameStarted = false;
                clearInterval(timerInterval);
                gameOverScreen.style.display = 'flex';
                gameOverScreen.setAttribute('data-reason', 'petted');
                document.getElementById('gameOverMessage').innerHTML =
      "<span style='color:#f85149; font-family:Cinzel, serif; font-size:1.2em; letter-spacing:2px;'>You were petted.</span>";
                document.getElementById('restartButton').innerHTML = 'We Continue';
                finalScores.innerHTML = `<span style='color:#2ea043;'>+${score} additions</span> &nbsp; <span style='color:#f85149;'>-${deletionsScore} deletions</span>`;
                drawGitGraph();
                if (gitGraphResults.length < maxGames) {
                    gitGraphResults.push({ score, deletions: deletionsScore });
                }
                uGGG();
                if (gitGraphResults.length === maxGames) {
                    setTimeout(showReport, 1500);

                }
            }
            function showReport() {
                startButton.style.display = 'none';
                reportScreen.style.display = 'block';
                scoreboard.style.display = 'none';
                let total = gitGraphResults.reduce((sum, g) => sum + Math.max(0, g.score - g.deletions), 0);
                let rank = getRank(total);
                const fedoraOption = document.getElementById('fedoraOption');
                if (rank === 'B|ackc4t_h@cker' || rank === 'Grey Cat Hacker') {
                    fedoraOption.style.display = 'flex';
                    catWearsFedora = true;
                }

                let rankColor = {
                    'Emmie': '#888',
                    'Copy-pawsta Cat': '#1e90ff',
                    'Script Kitty': '#f7c325',
                    'Pawthonista': '#a259e6',
                    'Grey Cat Hacker': '#2ea043',
                    'B|ackc4t_h@cker': '#2ea043'
                }[rank] || '#fff';
                let rankText = `<span style='font-size:2em; color:${rankColor}; font-weight:bold;'>${rank.replace(/\b\w/g, l => l.toUpperCase())}</span>`;
                let details = gitGraphResults.map((g, i) => `<div style='font-size:1.1em; margin:4px 0;'>Game ${i+1}: <span style='color:#2ea043;'>+${g.score}</span> <span style='color:#f85149;'>-${g.deletions}</span> = <b>${Math.max(0, g.score-g.deletions)}</b></div>`).join('');
                reportScreen.innerHTML = `<h2>7 Games Complete!</h2><div style='margin:12px 0 18px 0;'>Total Additions: <span style='color:#2ea043; font-size:1.3em;'>${total}</span></div>${details}<div style='margin:18px 0 8px 0;'>Rank:</div>${rankText}<div style='margin-top:18px;'><button id='resetSeriesBtn' style='font-size:1em; padding:8px 24px; border-radius:8px; border:none; background:#2ea043; color:white; cursor:pointer;'>Play Again</button></div>`;
                setTimeout(() => {
                    document.getElementById('resetSeriesBtn').onclick = () => {
                        gitGraphResults = [];
                        uGGG();
                        reportScreen.style.display = 'none';
                        startButton.style.display = 'inline-block';
                    };
                }, 100);
            }
            function drawGitGraph() {
                const ctx = gitGraph.getContext('2d');
                ctx.clearRect(0, 0, gitGraph.width, gitGraph.height);
                const net = Math.max(0, score - deletionsScore);
                const maxScore = 1000;
                const percent = Math.min(net / maxScore, 1);
                function lerp(a, b, t) { return a + (b - a) * t; }
                function hexToRgb(hex) {
                    hex = hex.replace('#', '');
                    if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                    const num = parseInt(hex, 16);
                    return [num >> 16, (num >> 8) & 0xff, num & 0xff];
                }
                function rgbToHex([r, g, b]) {
                    return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                }
                const grey = hexToRgb('#888');
                const green = hexToRgb('#2ea043');
                const color = [
                    Math.round(lerp(grey[0], green[0], percent)),
                    Math.round(lerp(grey[1], green[1], percent)),
                    Math.round(lerp(grey[2], green[2], percent))
                ];
                ctx.fillStyle = rgbToHex(color);
                ctx.fillRect(0, 0, gitGraph.width, gitGraph.height);
                ctx.strokeStyle = '#2ea043';
                ctx.lineWidth = 2;
                ctx.strokeRect(1, 1, gitGraph.width-2, gitGraph.height-2);
            }

            function updateGitCubeColor() {
                const net = Math.max(0, score - deletionsScore);
                const maxScore = 1000;
                const percent = Math.min(net / maxScore, 1);
                function lerp(a, b, t) { return a + (b - a) * t; }
                function hexToRgb(hex) {
                    hex = hex.replace('#', '');
                    if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                    const num = parseInt(hex, 16);
                    return [num >> 16, (num >> 8) & 0xff, num & 0xff];
                }
                function rgbToHex([r, g, b]) {
                    return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                }
                const grey = hexToRgb('#888');
                const green = hexToRgb('#2ea043');
                const color = [
                    Math.round(lerp(grey[0], green[0], percent)),
                    Math.round(lerp(grey[1], green[1], percent)),
                    Math.round(lerp(grey[2], green[2], percent))
                ];
                gitCube.style.background = rgbToHex(color);
            }

            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            let gameLoopRunning = false;
            function gameLoop() {
                if (!gameLoopRunning) return;

                update();
                draw();
                requestAnimationFrame(gameLoop);
            }

        startButton.addEventListener('click', () => {
            spawnRandomShelves();
            spawnCoffeeCups();
            if (gitGraphResults.length === maxGames) return;
            chaseSuccessCount = 0;
            gameStarted = true;
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            scoreboard.style.display = 'block';
            score = 0;
            deletionsScore = 0;
            gitAdditions.textContent = 0;
            gitDeletions.textContent = 0;
            additionsHistory = [];
            codeParticles = [];
            stealthState = 'idle';
            stealthTimer = 0;
            nextStealthEvent = Date.now() + 3000 + Math.random() * 5000;
            doorOpenProgress = 0;
            footprintsProgress = 0;
            handsProgress = 0;
            handsHoldTimer = 0;
            fSBP = 0;
            doorCloseProgress = 0;
            lastStealthFrame = Date.now();
            lastHandsSecond = null;
            scrubStainActive = false;
            scrubStainTimer = 0;
            scrubStainProgress = 0;
            scrubStainAlpha = 0;
            scrubStainX = null;
            scrubStainY = null;
            cat.x = 50;
            cat.y = 500;
            cat.velocityY = 0;
            cat.isJumping = false;
            codeMode = false;
            keys = {};
            round = 1;
            currentTime = baseTime;
            pBS();
            startTimer();
            if (!gameLoopRunning) {
                gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        });

        const fedoraCheckbox = document.getElementById('fedoraCheckbox');
        fedoraCheckbox.addEventListener('change', (event) => {
            catWearsFedora = event.target.checked;
        });

            restartButton.addEventListener('click', () => {
                startScreen.style.display = 'flex';
                gameOverScreen.style.display = 'none';
                scoreboard.style.display = 'none';
                uGGG();
                gameLoopRunning = false;
            });


        uGGG();
        scoreboard.style.display = 'none';
        gameLoopRunning = false;
</script>


