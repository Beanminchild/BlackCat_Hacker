<!DOCTYPE html><html><head><title>Black Cat Hacker</title><style>body{margin:0;overflow:hidden;background-color:#222}canvas{background-color:#728C69;display:block;margin:0 auto;position:relative;z-index:1}#startScreen{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:10}#startButton,#tutorialButton{padding:20px 40px;font-size:24px;background-color:#555;color:white;border:none;cursor:pointer}#scoreboard{position:absolute;top:20px;right:20px;font-size:24px;color:white;z-index:20}#gitScoreBar{z-index:21;position:relative;}#gitAdditions,#gitDeletions,#gitCube{z-index:22;position:relative;}</style></head><body><div id="timer" style="display:none;position:absolute;top:10px;left:10px;font-size:2em;color:#fff;background:rgba(0,0,0,0.7);padding:8px 18px;border-radius:8px;z-index:1000">05:00</div><div id="workday-message" style="display:none;position:absolute;top:50px;left:50%;transform:translateX(-50%);font-size:2.5em;color:#fff;background:rgba(0,0,0,0.85);padding:20px 40px;border-radius:12px;z-index:2000">work day over</div><div id="startScreen" style="display:flex;flex-direction:column;justify-content:center;align-items:center;position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgb(0,0,0);z-index:10"><div id="tutorialScreen" style="display:none;flex-direction:column;justify-content:center;align-items:center;position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgb(0,0,0);z-index=10"></div><h1 style="color:white;font-family:sans-serif;font-size:3em;margin-bottom:24px">B|ackC4t_H@cker</h1><div id="gitGraphGrid" style="display:grid;grid-template-columns:repeat(4,32px);grid-template-rows:repeat(2,32px);gap:12px;margin-bottom:24px;justify-content:center;align-items:center;width:max-content;margin-left:auto;margin-right:auto"><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:1;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:2;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:3;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:4;grid-row:1"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:1;grid-row:2"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:2;grid-row:2"></canvas><canvas class="gitGraphSquare" width="32" height="32" style="background:#181818;border-radius:6px;border:2px solid #222;box-shadow:0 2px 6px #0004;grid-column:3;grid-row:2"></canvas></div>
<div id="fedoraOption" style="margin-bottom: 20px; display: flex; align-items: center;">
  <input type="checkbox" id="fedoraCheckbox" style="margin-right: 10px;" checked>
  <label for="fedoraCheckbox" style="color: white; font-family: sans-serif;">Cat wears Fedora</label>
</div>
<button id="startButton" style="margin:0 auto 0 auto;display:block">Start Game</button><p><button id="tutorialButton" style="margin:0 auto 0 auto;display:block">How 2 Play</button></p><div id="reportScreen" style="display:none;margin-top:24px;color:white;font-family:sans-serif;background:#222;border-radius:12px;padding:24px 32px;box-shadow:0 4px 32px #000a;text-align:center"></div></div><div id="gameOverScreen" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.92);z-index:100;color:white;justify-content:center;align-items:center;flex-direction:column;font-family:sans-serif"><div style="background:#222;padding:32px 48px;border-radius:16px;box-shadow:0 4px 32px #000a;display:flex;flex-direction:column;align-items:center;gap:24px"><h1 id="gameOverMessage" style="margin:0;font-size:2.5em"></h1><div id="finalScores" style="font-size:1.3em"></div><canvas id="gitGraph" width="24" height="24" style="margin-top:12px;border-radius:4px;background:#181818;border:2px solid #222;box-shadow:0 2px 6px #0004"></canvas><button id="restartButton" style="margin-top:18px;font-size:1.1em;padding:10px 32px;border-radius:8px;border:none;background:#2ea043;color:white;cursor:pointer">Restart</button></div></div><div id="scoreboard"><div id="gitScoreBar" style="display:flex;align-items:center;gap:12px"><span style="background:#2ea043;color:white;border-radius:4px 0 0 4px;padding:4px 10px;font-family:monospace;font-size:20px;display:flex;align-items:center">+<span id="gitAdditions">0</span></span><span style="background:#f85149;color:white;border-radius:0 4px 4px 0;padding:4px 10px;font-family:monospace;font-size:20px;display:flex;align-items:center;opacity:0.9">-<span id="gitDeletions">0</span></span><span id="gitCube" style="width:24px;height:24px;margin-left:8px;border-radius:4px;background:#888;display:inline-block;border:2px solid #222;box-shadow:0 2px 6px #0004"></span></div></div><canvas id="gameCanvas"></canvas><script>
    let catWearsFedora = true;
    // --- Timer Mechanic ---
    let round = 1;
    let timerInterval = null;
    let baseTime = 120; // 5 minutes in seconds
    let timeDecrease = 20; // seconds decrease per round
    let currentTime = baseTime;

    function formatTime(secs) {
        const m = Math.floor(secs / 60).toString().padStart(2, '0');
        const s = (secs % 60).toString().padStart(2, '0');
        return `${m}:${s}`;
    }

    function updateTimerDisplay() {
        document.getElementById('timer').textContent = formatTime(currentTime);
    }

    function showTimer(show) {
        document.getElementById('timer').style.display = show ? 'block' : 'none';
    }

    function endRound() {
        clearInterval(timerInterval);
        showTimer(false);
        // Show game over screen with 'work day over' as the main message
        gameStarted = false;
        gameOverScreen.style.display = 'flex';
        gameOverScreen.setAttribute('data-reason', 'timeout');
        document.getElementById('gameOverMessage').textContent = 'work day over';
        finalScores.innerHTML = `<span style='color:#2ea043;'>+${score} additions</span> &nbsp; <span style='color:#f85149;'>-${deletionsScore} deletions</span>`;
        drawGitGraph();
        // --- Store result and update grid ---
        if (gitGraphResults.length < maxGames) {
            gitGraphResults.push({ score, deletions: deletionsScore });
        }
        updateGitGraphGrid();
        // --- If 7 games played, show report ---
        if (gitGraphResults.length === maxGames) {
            setTimeout(showReport, 1200); // Give a moment to the last game over
        }
    }

    function startTimer() {
        showTimer(true);
        updateTimerDisplay();
        timerInterval = setInterval(() => {
            currentTime--;
            updateTimerDisplay();
            if (currentTime <= 0) {
                endRound();
            }
        }, 1000);
    }

    function nextRound() {
        round++;
        currentTime = Math.max(20, baseTime - (round - 1) * timeDecrease);
        startTimer();
    }

    // Only start timer when a round actually starts (e.g., when gameplay begins)
    // Call startTimer() at the start of each round in your game logic.
    // --- Coffee Cup Mechanic ---
    let coffeeCups = [];
    const coffeeEmoji = '\u{2615}';
    function spawnCoffeeCups() {
        coffeeCups = [];
        const numCups = 1 + Math.floor(Math.random() * 3); // 1-3 cups
        let spots = [];
        // Only shelf spots (no desk spots)
        [...shelves, ...randomShelves].forEach(shelf => {
            spots.push({
                x: shelf.x + 20 + Math.random() * (shelf.width - 40),
                y: shelf.y - 18 + Math.random() * 4
            });
        });
        // Shuffle and pick
        for (let i = 0; i < numCups && spots.length > 0; i++) {
            const idx = Math.floor(Math.random() * spots.length);
            const pos = spots.splice(idx, 1)[0];
            coffeeCups.push({
                x: pos.x,
                y: pos.y,
                vx: 0,
                vy: 0,
                airborne: false,
                alpha: 1
            });
        }
    }
    function isCatNearCup(cup) {
        // Cat's center
        const catCenterX = cat.x + cat.width / 2;
        const catCenterY = cat.y + cat.height / 2;
        // Cup center
        const cupCenterX = cup.x + 10;
        const cupCenterY = cup.y + 10;
        return Math.abs(catCenterX - cupCenterX) < 32 && Math.abs(catCenterY - cupCenterY) < 32;
    }
    function pushCoffeeCup(cup) {
        if (cup.airborne) return;
        // Push direction: away from cat
        const catCenterX = cat.x + cat.width / 2;
        const cupCenterX = cup.x + 10;
        let dir = Math.sign(cupCenterX - catCenterX) || 1;
        cup.vx = dir * (2.5 + Math.random() * 1.5);
        cup.vy = -4.5 - Math.random() * 1.5;
        cup.airborne = true;
        // If hands are present, trigger chase
        if (stealthState === 'hands' && handsProgress === 1) {
            stealthState = 'handsChase';
            handsChaseActive = false;
        }
    }
    // --- GitGraph grid and report state ---
    let gitGraphResults = [];
    const maxGames = 7;
    function getRank(total) {
        if (total >= 7000) return 'Master B|ckc4t_h@cker';
        if (total >= 5000) return 'Grey Cat Hacker';
        if (total >= 3500) return 'Pythonista';
        if (total >= 2000) return 'Script kitty';
        if (total >= 1000) return 'Copy-pasta cat';
        return 'Hello World!';
    }
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = 800;
    canvas.height = 600;

    // Stealth mechanic variables
    let stealthState = 'idle'; // idle, doorOpening, footprints, hands, handsWait, footstepsBack, doorClosing, handsChase, scrubStain
    let scrubStainTimer = 0;
    let scrubStainProgress = 0;
    let scrubStainAlpha = 0;
    let scrubStainActive = false;
    let scrubFootstepsProgress = 0; // 0..1, for footsteps back to door
    let scrubStainX = null;
    let scrubStainY = null;
    let stealthTimer = 0;
    let nextStealthEvent = Date.now() + 3000 + Math.random() * 5000 //
    let doorOpenProgress = 0; // 0=closed, 1=open
    let footprintsProgress = 0; // 0=start, 1=at desk
    let handsProgress = 0; // 0=hidden, 1=fully shown
    let handsHoldTimer = 0; // ms hands have been fully shown
    let footstepsBackProgress = 0; // 0=at desk, 1=at door
    let doorCloseProgress = 0; // 0=open, 1=closed
    let lastStealthFrame = Date.now();

    // --- Meow/Chase feature ---
    let meowCount = 0;
    let meowTarget = 0;
    // --- Track successful chase avoidances ---
    let chaseSuccessCount = 0;
    let chaseSuccessThreshold = 1 + Math.floor(Math.random() * 3); // 1-3
    let handsChaseTimer = 0;
    let handsChaseStart = 0;
    let handsChasePos = { x: 0, y: 0 };
    let handsChaseActive = false;
    let handsChaseSpeed = 2.0; // px per frame

    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');
    const tutorialButton = document.getElementById('tutorialButton');
    const tutorialScreen = document.getElementById('reportScreen');
    const gitGraphGrid = document.getElementById('gitGraphGrid');
    const reportScreen = document.getElementById('reportScreen');
    const scoreboard = document.getElementById('scoreboard');
        // --- Draw the grid of 7 gitgraph squares on the home screen ---
        function updateGitGraphGrid() {
            const squares = gitGraphGrid.querySelectorAll('.gitGraphSquare');
            for (let i = 0; i < squares.length; i++) {
                const ctx = squares[i].getContext('2d');
                ctx.clearRect(0, 0, 32, 32);
                if (gitGraphResults[i]) {
                    // Color by (additions - deletions) for that game
                    const net = Math.max(0, gitGraphResults[i].score - gitGraphResults[i].deletions);
                    const maxScore = 1000;
                    const percent = Math.min(net / maxScore, 1);
                    function lerp(a, b, t) { return a + (b - a) * t; }
                    function hexToRgb(hex) {
                        hex = hex.replace('#', '');
                        if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                        const num = parseInt(hex, 16);
                        return [num >> 16, (num >> 8) & 0xff, num & 0xff];
                    }
                    function rgbToHex([r, g, b]) {
                        return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                    }
                    const grey = hexToRgb('#888');
                    const green = hexToRgb('#2ea043');
                    const color = [
                        Math.round(lerp(grey[0], green[0], percent)),
                        Math.round(lerp(grey[1], green[1], percent)),
                        Math.round(lerp(grey[2], green[2], percent))
                    ];
                    ctx.fillStyle = rgbToHex(color);
                    ctx.fillRect(0, 0, 32, 32);
                    ctx.strokeStyle = '#2ea043';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(1, 1, 30, 30);
                } else {
                    // Blank
                    ctx.fillStyle = '#181818';
                    ctx.fillRect(0, 0, 32, 32);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(1, 1, 30, 30);
                }
            }
        }

        let shelves = [];
        let randomShelves = [];


        const cat = {
            x: 50,
            y: 500,
            width: 20,
            height: 20,
            speed: 5,
            velocityY: 0,
            isJumping: false,
            color: 'black'
        };


        // Door position and size (moved to global scope for scrubStain)
        const doorX = 30;
        const doorY = 330;
        const doorW = 60;
        const doorH = 140;

        // Update desk to be at rightmost part of screen
        const deskWidth = 120;
        const deskHeight = 60;
        const desk = {
            x: canvas.width - deskWidth,
            y: canvas.height - deskHeight - 20, // 20px above bottom
        };

        // Move monitor to top of furthest right shelf
        const monitor = {
            x: 680, // rightmost shelf x
            y: 300, // shelf y minus monitor height
            width: 100,
            height: 100,
            label: 'Monitor'
        };


        let gameStarted = false;
        let codeMode = false;
        let score = 0;
        let codeParticles = [];
    const gitAdditions = document.getElementById('gitAdditions');
    const gitDeletions = document.getElementById('gitDeletions');
    const gitCube = document.getElementById('gitCube');
    const gameOverScreen = document.getElementById('gameOverScreen');
    //const tutorialScreen = document.getElementById('reportScreen');
    const finalScores = document.getElementById('finalScores');
    const gitGraph = document.getElementById('gitGraph');
    const restartButton = document.getElementById('restartButton');
    // Red deletions score
    let deletionsScore = 0;
    let lastHandsSecond = null;
    // For git graph
    let additionsHistory = [];

    function animateDeletionsScore(points) {
        let startScore = deletionsScore;
        let endScore = deletionsScore + points;
        const animationDuration = 20;
        const startTime = performance.now();

        function updateScore(currentTime) {
            const elapsedTime = currentTime - startTime;
            const progress = Math.min(elapsedTime / animationDuration, 1);
            const animatedScore = Math.floor(startScore + (endScore - startScore) * progress);
            gitDeletions.textContent = animatedScore;
            if (progress < 1) {
                requestAnimationFrame(updateScore);
            } else {
                deletionsScore = endScore;
                gitDeletions.textContent = deletionsScore;
            }
        }

        requestAnimationFrame(updateScore);
    }

        function isCatNearMonitor() {
            // Cat's center x and y
            const catCenterX = cat.x + cat.width / 2;
            const catCenterY = cat.y + cat.height / 2;
            // Monitor's center x and y
            const monitorCenterX = monitor.x + monitor.width / 2;
            const monitorCenterY = monitor.y + monitor.height/2

            if (Math.abs(catCenterX - monitorCenterX) < 40 && Math.abs(catCenterY - monitorCenterY) < 40) return true;

        }

         // Manually define the shelves
        shelves = [
            { x: 25, y: 315, width: 65, height: 20, color: 'transparent' },
            { x: 200, y: 400, width: 100, height: 20, color: '#4b371C' },
            { x: 325, y: 290, width: 150, height: 20, color: '#4b371C' },
            { x: 670, y: 380, width: 150, height: 20, color: '#4b371C' },
        ];

        function generateCodeParticle(score) {

            const codeSnippets = [
                { text: "console.log(meow')", consoleColor: 'white', logColor: 'green', meowColor: 'lightblue' },
                { text: "cat.jump()", consoleColor: 'white', logColor: 'orange', meowColor: 'white' },
                { text: "if ( cat.Slep) { slepMore() }", consoleColor: 'white', logColor: 'yellow', meowColor: 'white' },
                { text: "let catFood = new Food('tuna')", consoleColor: 'white', logColor: 'red', meowColor: 'white' },
                { text: "cat.play('yarn')", consoleColor: 'white', logColor: 'purple', meowColor: 'white' },
                { text: "debug('cat position : ' + cat.x + ', ' + cat.y)", consoleColor: 'white', logColor: 'cyan', meowColor: 'white' },
                { text: "error ('no more catnip')", consoleColor: 'white', logColor: 'red', meowColor: 'white' },
                { text: "function headscratch() { return ' purr ' }", consoleColor: 'white', logColor: 'lime', meowColor: 'white' },
                { text: "cat.hunt('laser pointer')", consoleColor: 'white', logColor: 'pink', meowColor: 'white' },
                {text: "while bowlEmpty(true) { meow() }", consoleColor: 'white', logColor: 'lightgreen', meowColor: 'red' }
            ];

            const snippet = codeSnippets[Math.floor(Math.random() * codeSnippets.length)];

            codeParticles.push({
                x: monitor.x - 100, // spawn to the left of the monitor
                y: monitor.y + monitor.height / 2, // vertically centered on monitor
                text: snippet.text,
                consoleColor: snippet.consoleColor,
                logColor: snippet.logColor,
                meowColor: snippet.meowColor,
                size: 12,
                speedX: Math.random() * 2 - 1,
                speedY: Math.random() * -2 - 1,
                targetX: canvas.width - 25,
                targetY: 50,
                alpha: 1
            });
        }

    function triggerScrubStain(x, y) {
        // Cancel hands/monitor/chase mode and start scrubStain
        if (stealthState === 'hands' || stealthState === 'handsChase') {
            handsChaseActive = false;
        }
        stealthState = 'scrubStain';
        scrubStainTimer = 0;
        scrubStainProgress = 0;
        scrubStainAlpha = 1;
        scrubStainActive = true;
        // Set stain position (default to center if not provided)
        scrubStainX = (typeof x === 'number') ? x : canvas.width / 2;
        scrubStainY = (typeof y === 'number') ? y : (canvas.height / 2 + 80);
    }

    function endHandsMonitorAndTriggerWalkBack() {
        // End hands/monitor sequence and trigger walk back and door close
        stealthState = 'footstepsBack';
        footstepsBackProgress = 0;
        lastHandsSecond = null;
        handsHoldTimer = 0;
    }

    function spawnRandomShelves() {
        randomShelves = [];
        const numShelves = Math.floor(Math.random() * 3); // 0-3,
        for (let i = 0; i < numShelves; i++) {
            // Define allowed x/y ranges (avoid overlapping desk/door/monitor)
            // Example: x: 80 to 600, y: 120 to 500
            const x = 80 + Math.random() * 520;
            const y = 180 + Math.random() * 30;
            const width = 60 + Math.random() * 40; // 60-140px
            const height = 20;
            randomShelves.push({ x, y, width, height, color: '#7a5c3c' });
        }
    }

    function update() {
            // Update coffee cups
            let cupsToRemove = [];
            coffeeCups.forEach((cup, i) => {
                if (cup.airborne) {
                    cup.x += cup.vx;
                    cup.y += cup.vy;
                    cup.vy += 0.35; // gravity
                    // Desk collision
                    if (cup.y + 20 > desk.y && cup.vy > 0) {
                        cup.y = desk.y - 20;
                        // Trigger spill and scrubStain at cup location
                        if (!scrubStainActive) {
                            triggerScrubStain(cup.x + 10, desk.y - 10);
                        }
                        cup.vy *= -0.35;
                        cup.vx *= 0.6;
                        if (Math.abs(cup.vy) < 1.2) {
                            cup.vy = 0;
                            cup.airborne = false;
                            cupsToRemove.push(i); // Mark for removal
                        }
                    }
                    // Shelf collision
                    shelves.forEach(shelf => {
                        if (
                            cup.x + 20 > shelf.x &&
                            cup.x < shelf.x + shelf.width &&
                            cup.y + 20 > shelf.y &&
                            cup.y < shelf.y + shelf.height &&
                            cup.vy > 0
                        ) {
                            cup.y = shelf.y - 20;
                            cup.vy *= -0.35;
                            cup.vx *= 0.6;
                            if (Math.abs(cup.vy) < 1.2) {
                                cup.vy = 0;
                                cup.airborne = false;
                            }
                        }
                    });
                    // If cup falls off desk/screen, trigger scrubStain at last position
                    if ((cup.y > canvas.height - 10) && !scrubStainActive) {
                        triggerScrubStain(cup.x + 10, cup.y + 10);
                    }
                    // Fade out if off screen
                    if (cup.x < -40 || cup.x > canvas.width + 40 || cup.y > canvas.height + 40) {
                        cup.alpha -= 0.04;
                        if (cup.alpha <= 0) coffeeCups.splice(i, 1);
                    }
                }
            });
            // Remove cups that landed
            if (cupsToRemove.length > 0) {
                // Remove from highest index to lowest to avoid index shift
                cupsToRemove.sort((a, b) => b - a).forEach(idx => coffeeCups.splice(idx, 1));
            }

            if (!gameStarted) return;

            // Scrub stain mechanic
            if (stealthState === 'scrubStain') {
                scrubStainTimer++;
                // Animate hands scrubbing for 2 seconds
                if (scrubStainTimer < 120) {
                    scrubStainProgress = scrubStainTimer / 120;
                    // Fade out stain as hands scrub
                    scrubStainAlpha = 1 - (scrubStainTimer / 120);
                } else if (scrubStainTimer < 270) // footsteps phase unchanged
                {
                    scrubStainProgress = 1;
                    scrubFootstepsProgress = (scrubStainTimer-120)/150;
                    scrubStainAlpha = 0; // keep stain gone
                } else if (scrubStainTimer < 330) // smoother door closing (60 frames)
                {
                    // Animate door closing
                    scrubStainAlpha = 0;
                } else {
                    // Reset to idle
                    scrubStainActive = false;
                    scrubFootstepsProgress = 0;
                    stealthState = 'idle';
                    nextStealthEvent = Date.now() + 3000 + Math.random() * 4000;
                }
                // Do NOT return here; allow rest of update to run so game continues
            }

            // Stealth mechanic timing
            const now = Date.now();
            if (stealthState === 'handsChase') {
                // --- Hands chase the cat ---
                if (!handsChaseActive) {
                    // Initialize chase
                    handsChaseActive = true;
                    handsChaseStart = now;
                    handsChaseTimer = 0;
                    // Start hands at monitor
                    handsChasePos.x = monitor.x + monitor.width / 2;
                    handsChasePos.y = monitor.y + monitor.height - 10;
                }
                // Move hands toward cat
                const catCenterX = cat.x + cat.width / 2;
                const catCenterY = cat.y + cat.height / 2;
                const dx = catCenterX - handsChasePos.x;
                const dy = catCenterY - handsChasePos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    handsChasePos.x += (dx / dist) * handsChaseSpeed;
                    handsChasePos.y += (dy / dist) * handsChaseSpeed;
                }
                // Check collision with cat
                if (
                    handsChasePos.x > cat.x - 18 &&
                    handsChasePos.x < cat.x + cat.width + 18 &&
                    handsChasePos.y > cat.y - 16 &&
                    handsChasePos.y < cat.y + cat.height + 16
                ) {
                    endGame();
                    return;
                }
                // Timer for chase
                handsChaseTimer = now - handsChaseStart;
                if (handsChaseTimer > 7000) {
                    // Hands return to monitor, but count as a successful avoidance
                    handsChaseActive = false;
                    chaseSuccessCount++;
                    meowCount = 0;
                    meowTarget = 0;
                    if (chaseSuccessCount >= chaseSuccessThreshold) {
                        // End hands/monitor and trigger walk back/door close
                        endHandsMonitorAndTriggerWalkBack();
                        chaseSuccessCount = 0;
                        // Re-randomize threshold for next event
                        chaseSuccessThreshold = 1 + Math.floor(Math.random() * 3);
                    } else {
                        // Resume hands at monitor
                        stealthState = 'hands';
                        handsProgress = 1;
                    }
                }
            } else {
                if (now > nextStealthEvent && stealthState === 'idle') {
                    chaseSuccessCount = 0; // Reset for new event
                    chaseSuccessThreshold = 1 + Math.floor(Math.random() * 3); // Re-randomize for new event
                    stealthState = 'doorOpening';
                    doorOpenProgress = 0;
                    footprintsProgress = 0;
                    handsProgress = 0;
                    //handsHoldTimer = 0;
                    footstepsBackProgress = 0;
                    doorCloseProgress = 0;
                }
                if (stealthState === 'doorOpening') {
                    doorOpenProgress += 0.02;
                    if (doorOpenProgress >= 1) {
                        doorOpenProgress = 1;
                        stealthState = 'footprints';
                    }
                } else if (stealthState === 'footprints') {
                    footprintsProgress += 0.008;
                    if (footprintsProgress >= 1) {
                        footprintsProgress = 1;
                        stealthState = 'hands';
                        handsHoldTimer = 0;
                        lastHandsSecond = null;
                    }
                } else if (stealthState === 'hands') {
                    if (handsProgress < 1) {
                        handsProgress += 0.02;
                        if (handsProgress > 1) handsProgress = 1;
                    } else {
                        handsHoldTimer += 16; // ~1 frame at 60fps
                        // --- Red deletions score: count up every second hands are in front of monitor ---
                        let handsSeconds = Math.floor(handsHoldTimer / 1000);
                        if (lastHandsSecond !== handsSeconds) {
                            lastHandsSecond = handsSeconds;
                            animateDeletionsScore(5);
                        }
                        // --- GAME OVER if cat is in front of monitor when hands are there ---
                        if (isCatNearMonitor()) {
                            endGame();
                            return;
                        }
                        if (handsHoldTimer >= 30000) { // 30 seconds in ms
                            stealthState = 'footstepsBack';
                            footstepsBackProgress = 0;
                            lastHandsSecond = null;
                        }
                    }
                } else if (stealthState === 'footstepsBack') {
                    footstepsBackProgress += 0.012; // a bit faster than forward
                    if (footstepsBackProgress >= 1) {
                        footstepsBackProgress = 1;
                        stealthState = 'doorClosing';
                        doorCloseProgress = 0;
                    }
                } else if (stealthState === 'doorClosing') {
                    doorCloseProgress += 0.02;
                    if (doorCloseProgress >= 1) {
                        doorCloseProgress = 1;
                        stealthState = 'idle';
                        nextStealthEvent = Date.now() + 4000 + Math.random() * 3000;
                    }
                }
            }

            // Auto-activate code mode if cat is in front of monitor
            if (isCatNearMonitor()) {
                codeMode = true;
            } else {
                codeMode = false;
            }

            // Gravity
            cat.velocityY += 0.5;
            cat.y += cat.velocityY;

            // Keep cat on the desk
            let onGround = false;
            if (cat.y + cat.height > desk.y) {
                cat.y = desk.y - cat.height;
                cat.velocityY = 0;
                cat.isJumping = false;
                onGround = true;
            }

            // Shelf collision detection
            shelves.concat(randomShelves).forEach(shelf => {
                if (cat.x < shelf.x + shelf.width &&
                    cat.x + cat.width > shelf.x &&
                    cat.y + cat.height > shelf.y &&
                    cat.y < shelf.y + shelf.height &&
                    cat.velocityY >= 0) {
                    cat.y = shelf.y - cat.height;
                    cat.velocityY = 0;
                    cat.isJumping = false;
                    onGround = true;
                }
            });

            // Movement
            if (keys['ArrowLeft']) {
                cat.x -= cat.speed;
            }
            if (keys['ArrowRight']) {
                cat.x += cat.speed;
            }

            // Keep cat within bounds
            if (cat.x < 0) {
                cat.x = 0;
            }
            if (cat.x + cat.width > canvas.width) {
                cat.x = canvas.width - cat.width;
            }


            // Update code particles and meow particles
            codeParticles.forEach((particle, index) => {
                particle.x += particle.speedX;
                particle.y += particle.speedY;
                // For 'meow' particles, float up and fade slower
                if (particle.isMeow) {
                    // Move toward target, but mostly float up
                    const dx = (particle.targetX - particle.x) * 0.04;
                    const dy = (particle.targetY - particle.y) * 0.04;
                    particle.x += dx;
                    particle.y += dy;
                    particle.alpha -= 0.008;
                    if (particle.alpha <= 0.01) {
                        codeParticles.splice(index, 1);
                    }
                } else {
                    const dx = particle.targetX - particle.x;
                    const dy = particle.targetY - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 10) {
                        codeParticles.splice(index, 1);

                    }
                    particle.alpha -= 0.01;
                    if (particle.alpha <= 0) {
                        codeParticles.splice(index, 1);
                    }
                }
            });

            // Track additions history for git graph
            if (gameStarted && additionsHistory.length < 32) {
                additionsHistory.push(score);
            }
        }

    function drawScrubStain() {
        // Draw coffee stain at the triggered location
        if (scrubStainActive && scrubStainX !== null && scrubStainY !== null) {
            const stainX = scrubStainX;
            const stainY = scrubStainY;
            ctx.save();
            ctx.globalAlpha = scrubStainAlpha;
            // Draw stain
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(stainX, stainY, 38 + Math.sin(scrubStainTimer/6)*2, 0, 2 * Math.PI);
            ctx.fillStyle = '#6b3e26';
            ctx.fill();
            ctx.globalAlpha = Math.min(1, scrubStainAlpha + 0.2);
            ctx.beginPath();
            ctx.arc(stainX+10, stainY-8, 12, 0, 2 * Math.PI);
            ctx.arc(stainX-14, stainY+6, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#8d5c3c';
            ctx.fill();
            ctx.restore();

            // Draw two hands like monitor/chase hands, one doing a circular scrubbing motion
            if (scrubStainTimer < 120) {
                // Hand 1 (left) - static, like monitor hand
                let hand1X = stainX - 28;
                let hand1Y = stainY - 32;
                drawGameHand(hand1X, hand1Y, 1, 0.9);
                // Hand 2 (right) - circular scrubbing motion
                let angle = (scrubStainTimer/18) * 2 * Math.PI;
                let radius = 22;
                let hand2X = stainX + Math.cos(angle) * radius + 18;
                let hand2Y = stainY + Math.sin(angle) * radius - 18;
                drawGameHand(hand2X, hand2Y, 1, 1);
            } else if (scrubStainTimer < 2440) {
                // Animate footsteps walking back to door
                let t = scrubFootstepsProgress;
                let startX = stainX;
                let startY = stainY + 18;
                let endX = doorX + doorW/2;
                let endY = doorY + doorH - 18;
                let footX = startX + (endX - startX) * t;
                let footY = startY + (endY - startY) * t;
                // Draw a series of footsteps along the path
                let steps = 8;

                for (let i = 0; i < steps; i++) {
                    let stepT = i / (steps-1);
                    let sx = startX + (endX - startX) * stepT;
                    let sy = startY + (endY - startY) * stepT;
                    ctx.save();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = Math.max(0, Math.min(1, (t-stepT)*2));
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, 8, 4, (i%2===0?0:Math.PI/8), 0, 2*Math.PI);
                    ctx.fillStyle = '#444';
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
    }

    // Draw a hand similar to monitor/chase hands
    function drawGameHand(x, y, scale=1, alpha=1) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        // Remove any shadow for hands
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
        // Palm
        ctx.beginPath();
        ctx.ellipse(0, 0, 22, 16, Math.PI/10, 0, 2*Math.PI);
        ctx.fillStyle = '#f3e2c7';
        ctx.fill();
        // Thumb
        ctx.beginPath();
        ctx.ellipse(-16, 2, 7, 12, -Math.PI/3, 0, 2*Math.PI);
        ctx.fillStyle = '#e2c7a0';
        ctx.fill();
        // Fingers
        for (let i = -1.2; i <= 1.2; i += 0.8) {
            ctx.beginPath();
            ctx.ellipse(10 + i*7, -10, 6, 14, Math.PI/8 + i*0.1, 0, 2*Math.PI);
            ctx.fillStyle = '#f3e2c7';
            ctx.fill();
        }
        ctx.restore();
    }

    function draw() {
            // Reset any unbalanced context states for MacOS Strict stack management
            let resetCount = 0;
            while (resetCount < 100) { // Safety limit
                try {
                    ctx.restore();
                    resetCount++;
                } catch (e) { // reset until stack is empty and throws stack underflow or empty the save stack by 100 per frame
                    break;
                }
            }

            // Start with a fresh state
            ctx.save();

            // --- BACKGROUND LAYERS ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw wall (upper background)
            ctx.fillStyle = '#728C69';
            // Lower the wall so it ends closer to the desk
            const wallBottomY = desk.y - 60; // was desk.y - 241, now much closer
            ctx.fillRect(0, 0, canvas.width, wallBottomY);

            // Draw floor area (lower background, below floorboard)
            const floorboardY = wallBottomY;
            ctx.fillStyle = '#bcae99'; // lighter, warm floor color
            ctx.fillRect(0, floorboardY, canvas.width, canvas.height - floorboardY);

            // Draw floorboard (horizontal plank)
            ctx.save();
            ctx.shadowColor = '#222a'; // dark shadow color
            ctx.shadowBlur = 20;       // blur radius for soft shadow
            ctx.fillStyle = '#6b4a2b';
            ctx.fillRect(0, floorboardY - 8, canvas.width, 16);
            ctx.restore();

            // Update gitCube color live based on (additions - deletions)
            updateGitCubeColor();
            // --- BACKGROUND ELEMENTS ---

            // (Removed blue ellipses/floor gradient)

            // Draw scrub stain if active (should be above carpet)
            if (scrubStainActive) {
                drawScrubStain();
            }

            // Draw floorboard (a thin, dark ellipse at the back of the floor)
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = '#4b371c';
            ctx.beginPath();
            //ctx.ellipse(canvas.width / 2, desk.y + 8, canvas.width * 0.48 * 0.98, 13, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Draw sky background and sun (moves diagonally behind the window)
            const windowX = canvas.width / 2 - 70;
            const windowY = 220;

            // Sky color gradient based on sunProgress (0=day, 0.5=orange, 1=purple)
            let windowSunProgress = 0;
            if (gameStarted && baseTime > 0) {
                windowSunProgress = 1 - (currentTime / baseTime);
                if (windowSunProgress < 0) windowSunProgress = 0;
                if (windowSunProgress > 1) windowSunProgress = 1;
            } else {
                windowSunProgress = 0;
            }
            // Interpolate sky color: blue (#7ecfff) -> orange (#ffb347) -> purple (#6a3fa0)
            function lerpColor(a, b, t) {
                const ah = parseInt(a.replace('#',''),16), bh = parseInt(b.replace('#',''),16);
                const ar = (ah>>16)&0xff, ag = (ah>>8)&0xff, ab = ah&0xff;
                const br = (bh>>16)&0xff, bg = (bh>>8)&0xff, bb = bh&0xff;
                return '#' + [
                    Math.round(ar + (br-ar)*t).toString(16).padStart(2,'0'),
                    Math.round(ag + (bg-ag)*t).toString(16).padStart(2,'0'),
                    Math.round(ab + (bb-ab)*t).toString(16).padStart(2,'0')
                ].join('');
            }
            let skyColor;
            if (windowSunProgress < 0.5) {
                // Blue to orange
                skyColor = lerpColor('#7ecfff', '#ffb347', windowSunProgress*2);
            } else {
                // Orange to purple
                skyColor = lerpColor('#ffb347', '#6a3fa0', (windowSunProgress-0.5)*2);
            }
            // Draw sky background behind window
            ctx.save();
            ctx.beginPath();
            ctx.rect(windowX, windowY, 140, 80);
            ctx.closePath();
            ctx.clip();
            // Gradient sky
            let windowGrad = ctx.createLinearGradient(windowX, windowY, windowX, windowY+80);
            windowGrad.addColorStop(0, skyColor);
            windowGrad.addColorStop(1, '#fff');
            ctx.fillStyle = windowGrad;
            ctx.fillRect(windowX, windowY, 140, 80);

            // --- Clouds ---
            if (!draw.clouds) {
                draw.clouds = [];
                for (let i=0; i<3; i++) {
                    draw.clouds.push({
                        x: windowX + Math.random()*140,
                        y: windowY + 10 + Math.random()*50,
                        speed: 0.15 + Math.random()*0.12,
                        size: 18 + Math.random()*12,
                        offset: Math.random()*1000
                    });
                }
            }
            // Move and draw clouds
            for (let i=0; i<draw.clouds.length; i++) {
                let c = draw.clouds[i];
                // Clouds move only during game
                if (gameStarted) {
                    c.x += c.speed;
                    if (c.x > windowX+140+30) {
                        c.x = windowX-40;
                        c.y = windowY + 10 + Math.random()*50;
                        c.size = 18 + Math.random()*12;
                        c.speed = 0.15 + Math.random() * 0.12;
                    }
                }

                // Draw cloud (simple ellipses)
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(c.x, c.y, c.size, c.size*0.6, 0, 0, 2*Math.PI);
                ctx.ellipse(c.x+0.6*c.size, c.y+2, c.size*0.7, c.size*0.4, 0, 0, 2*Math.PI);
                ctx.ellipse(c.x-0.7*c.size, c.y+3, c.size*0.5, c.size*0.3, 0, 0, 2*Math.PI);
                ctx.fill();
                ctx.restore();
            }
            ctx.restore();
            // Sun animation: moves from top-left to bottom-right of window as time passes, tied to timer
            let sunProgress = 0;
            if (gameStarted && baseTime > 0) {
                sunProgress = 1 - (currentTime / baseTime);
                if (sunProgress < 0) sunProgress = 0;
                if (sunProgress > 1) sunProgress = 1;
            } else {
                sunProgress = 0;
            }
            // Sun path: from (windowX+20, windowY+20) to (windowX+120, windowY+70)
            const sunStart = { x: windowX + 20, y: windowY + 20 };
            const sunEnd = { x: windowX + 120, y: windowY + 70 };
            const sunX = sunStart.x + (sunEnd.x - sunStart.x) * windowSunProgress;
            const sunY = sunStart.y + (sunEnd.y - sunStart.y) * windowSunProgress;
            // Draw sun behind window
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.beginPath();
            ctx.arc(sunX, sunY, 18, 0, 2 * Math.PI);
            ctx.fillStyle = 'orange';
            ctx.shadowColor = 'yellow';
            ctx.shadowBlur = 24;
            ctx.fill();
            ctx.restore();

            // Draw window (centered, more transparent so sun is visible) with shadow
            ctx.save();
            ctx.shadowColor = '#2226'; // less intense shadow
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.globalAlpha = 0.55;
            ctx.fillStyle = '#e0f7fa';
            ctx.fillRect(windowX, windowY, 140, 80);
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            ctx.strokeStyle = '#b0c4de';
            ctx.lineWidth = 6;
            ctx.strokeRect(windowX, windowY, 140, 80);
            // Window panes
            ctx.strokeStyle = '#b0c4de';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(windowX + 70, windowY);
            ctx.lineTo(windowX + 70, windowY + 80);
            ctx.moveTo(windowX, windowY + 40);
            ctx.lineTo(windowX + 140, windowY + 40);
            ctx.stroke();
            ctx.restore();

            // Draw door (closed, opening, open, closing) with shadow
            ctx.save();
            ctx.shadowColor = '#222a';
            ctx.shadowBlur = 18;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            let doorOpen = 0;
            if (
                stealthState === 'doorOpening' ||
                stealthState === 'footprints' ||
                stealthState === 'hands' ||
                stealthState === 'handsWait' ||
                stealthState === 'footstepsBack' ||
                (stealthState === 'scrubStain' && scrubStainTimer < 270) // Door stays open during scrub and footsteps
            ) {
                doorOpen = doorOpenProgress;
            } else if (stealthState === 'doorClosing' || (stealthState === 'scrubStain' && scrubStainTimer >= 270 && scrubStainTimer < 330)) {
                // Door closes after footsteps return, smoother (60 frames)
                let t = (stealthState === 'scrubStain') ? (scrubStainTimer-270)/60 : doorCloseProgress;
                doorOpen = 1 - t;
            } else {
                doorOpen = 0;
            }
// params
const doorW = 60, doorH = 135;
const hingeLeft = true;             // set false for right hinge
const hingeX = hingeLeft ? doorX : doorX + doorW;
const hingeY = doorY + doorH / 2;
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
const t = Math.max(0, Math.min(1, doorOpen)); // 0..1
const eased = easeOutCubic(t);
const maxAngle = Math.PI / 2 * 0.98; // nearly 90°
const angle = (hingeLeft ? -1 : 1) * maxAngle * eased;

// door thickness and perspective factors
const thickness = 12;                 // visible edge thickness in px
const depthScale = 0.6;              // how "thin" the face becomes at full open
const skew = 0.6;                     // skew factor for trapezoid edge


if (t > 0) {
    // Draw black rectangle behind the open door to simulate a dark room
        ctx.save();
        ctx.fillStyle = 'black';
        // Cover the entire door frame area
        ctx.fillRect(doorX, doorY, doorW, doorH);
        ctx.restore();

    ctx.save();
    // move to hinge
    ctx.translate(hingeX, hingeY);
    //ctx.rotate(angle); // dont need this this is the bad rotation around the wrong axis

    // Compute face transform: draw rect with hinge at x=0, y=-doorH/2
    // To fake perspective, scale X slightly based on angle
    const faceScaleX = 1 - Math.abs(Math.sin(angle)) * depthScale;
    ctx.save();
    ctx.scale(faceScaleX, 1);
    ctx.fillStyle = '#5a3c1a';
    ctx.fillRect(0, -doorH/2, doorW, doorH);
    ctx.strokeStyle = '#3a220a';
    ctx.lineWidth = 5 ;
    ctx.strokeRect(0, -doorH/2, doorW, doorH);
    // knob drawn in face local coords; adjust for scale
    const knobLocalX = doorW - 8;
    const knobLocalY = 0;
    ctx.beginPath();
    ctx.arc(knobLocalX, knobLocalY, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#eab676';
    ctx.fill();
    ctx.restore(); // restore from scale

    // draw visible edge (the door thickness) as a trapezoid
    // Edge direction depends on hinge side and sign of angle
    const sign = hingeLeft ? 1 : -1;
    const absAng = Math.abs(angle);
    if (absAng > 0.01) {
        // tip location at outer edge of face (in rotated space)
        const tipX = Math.cos(0) * doorW; // before rotation; we're in rotated coords
        const tipTopY = -doorH/4;
        const tipBottomY = doorH/4;

        // compute offset for thickness using angle
        const edgeOffsetX = sign * thickness * Math.cos(absAng) ;
        const edgeOffsetY = thickness * Math.sin(absAng) * skew;

        ctx.beginPath();
        // top outer corner
        ctx.moveTo(doorW, -doorH/2);
        // top outer + offset
        ctx.lineTo(doorW + edgeOffsetX, -doorH/2 + edgeOffsetY);
        // bottom outer + offset
        ctx.lineTo(doorW + edgeOffsetX, doorH/2 + edgeOffsetY);
        // bottom outer
        ctx.lineTo(doorW, doorH/2);
        ctx.closePath();
        // darker color for edge
        ctx.fillStyle = '#452a12';
        ctx.fill();
        ctx.strokeStyle = '#2c1907';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    ctx.restore();

<!--    // light beam: compute world coords of door tip-->
<!--    const worldAngle = angle; // rotation applied about hinge-->
<!--    const tipWorldX = hingeX + Math.cos(worldAngle) * doorW * (1);-->
<!--    const tipWorldY = hingeY + Math.sin(worldAngle) * doorW * (1);-->

    ctx.save();
    ctx.globalAlpha = 0.5 * eased;
<!--    //const grad = ctx.createLinearGradient(tipWorldX, tipWorldY, tipWorldX + 200, tipWorldY + 80);-->
<!--    grad.addColorStop(0, 'rgba(255,255,180,0.7)');-->
<!--    grad.addColorStop(1, 'rgba(255,255,180,0)');-->
<!--    ctx.fillStyle = grad;-->
    ctx.beginPath();
    ctx.moveTo(hingeX, hingeY);
<!--    ctx.lineTo(tipWorldX + 200, tipWorldY - 30);-->
<!--    ctx.lineTo(tipWorldX + 200, tipWorldY + 150);-->
    ctx.closePath();
    ctx.fill();
    ctx.restore();

} else {
  // closed door
  ctx.save();
  ctx.fillStyle = '#5a3c1a';
  ctx.fillRect(doorX, doorY, doorW, doorH);
  ctx.strokeStyle = '#3a220a';
  ctx.lineWidth = 5;
  ctx.strokeRect(doorX, doorY, doorW, doorH);
  ctx.beginPath();
  ctx.arc(doorX + doorW - 8, doorY + doorH/2, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#eab676';
  ctx.fill();
  ctx.restore();
}

            // --- END BACKGROUND ---

            // Draw desk
            ctx.save();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = desk.color;
            ctx.fillRect(desk.x, desk.y, desk.width, desk.height);
            ctx.restore();

            // Draw stain above desk
            drawScrubStain();

            // Draw shelves
            shelves.forEach(shelf => {
                ctx.fillStyle = shelf.color;
                ctx.fillRect(shelf.x, shelf.y, shelf.width, shelf.height);
            });
            // Draw random shelves
            randomShelves.forEach(shelf => {
                ctx.fillStyle = shelf.color;
                ctx.fillRect(shelf.x, shelf.y, shelf.width, shelf.height);
            });
            // Draw little black legs from the furthest right shelf to the desk
            const rightShelf = shelves.reduce((a, b) => (a.x > b.x ? a : b));
            const numLegs = 2;
            const legSpacing = rightShelf.width / (numLegs + 1);
            ctx.save();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            for (let i = 1; i <= numLegs; i++) {
                const legX = rightShelf.x + i * legSpacing;
                const legYStart = rightShelf.y + rightShelf.height;
                const legYEnd = desk.y;
                ctx.beginPath();
                ctx.moveTo(legX, legYStart);
                ctx.lineTo(legX, legYEnd);
                ctx.stroke();
            }
            ctx.restore();

            // Draw coffee cups (AFTER desk and shelves, so cups are visible on top)
            coffeeCups.forEach(cup => {
                ctx.save();
                ctx.globalAlpha = cup.alpha;
                ctx.font = '32px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                // Offset y so cup sits on surface
                ctx.fillText(coffeeEmoji, cup.x + 16, cup.y + 28);
                ctx.restore();
            });

            // --- STEALTH: CS footprints ---
            const steps = 8;
            if (stealthState === 'footprints' || stealthState === 'hands') {
                // Animate footprints from door toward desk
                for (let i = 0; i < steps; i++) {
                    const t = i / (steps - 1);
                    if (t > footprintsProgress) break;
                    // Path from door to desk
                    const fx = doorX + 60 + (canvas.width - (doorX + 60)) * t;
                    const fy = doorY + 140 + (desk.y - (doorY + 70)) * t * 0.8;
                    ctx.save();
                    ctx.globalAlpha = 0.5 + 0.5 * t;
                    ctx.fillStyle = '#222';
                    // Remove any shadow for footsteps
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.beginPath();
                    ctx.ellipse(fx, fy, 10, 5, (i%2===0?0.2:-0.2), 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (stealthState === 'footstepsBack') {
                // Animate footprints disappearing one by one back to the door
                // Show only the first N footprints, where N decreases as footstepsBackProgress increases
                const gone = Math.floor(steps * footstepsBackProgress + 0.001);
                for (let i = 0; i < steps - gone; i++) {
                    const t = i / (steps - 1);
                    const fx = doorX + 60 + (canvas.width - (doorX + 60)) * t;
                    const fy = doorY + 140 + (desk.y - (doorY + 70)) * t * 0.8;
                    ctx.save();
                    ctx.globalAlpha = 0.5 + 0.5 * t;
                    ctx.fillStyle = '#222';
                    // Remove any shadow for footsteps
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    ctx.beginPath();
                    ctx.ellipse(fx, fy, 10, 5, (i%2===0?0.2:-0.2), 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Draw monitor as emoji
            ctx.font = `${monitor.width}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('\u{1F4BB}', monitor.x + monitor.width/2, monitor.y);

            // --- HANDS CHASE DRAW ---
            if (stealthState === 'handsChase' && handsChaseActive) {
                // Draw hands at handsChasePos
                ctx.save();
                ctx.globalAlpha = 1;
                // Remove any shadow for hands
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                // Animate hands at handsChasePos
                const handY = handsChasePos.y;
                // Left hand
                ctx.fillStyle = '#eab676';
                ctx.beginPath();
                ctx.ellipse(handsChasePos.x - 25, handY, 18, 16, -0.2, 0, Math.PI*2);
                ctx.fill();
                // Fingers (left)
                for (let f=0; f<4; f++) {
                    ctx.beginPath();
                    ctx.ellipse(handsChasePos.x - 35 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                    ctx.fill();
                }
                // Right hand
                ctx.beginPath();
                ctx.ellipse(handsChasePos.x + 25, handY, 18, 16, 0.2, 0, Math.PI*2);
                ctx.fill();
                // Fingers (right)
                for (let f=0; f<4; f++) {
                    ctx.beginPath();
                    ctx.ellipse(handsChasePos.x + 15 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
                // Draw a timer bar above the cat
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#f85149';
                let chaseBarW = 120;
                let chaseBarH = 10;
                let chaseBarX = cat.x + cat.width/2 - chaseBarW/2;
                let chaseBarY = cat.y - 24;
                let chaseElapsed = Math.min(1, handsChaseTimer/7000);
                ctx.fillRect(chaseBarX, chaseBarY, chaseBarW * (1-chaseElapsed), chaseBarH);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(chaseBarX, chaseBarY, chaseBarW, chaseBarH);
                ctx.restore();

            }
            // --- STEALTH: hands in front of monitor ---
            if (stealthState === 'hands') {
                // Animate hands rising up in front of monitor
                const handY = monitor.y + monitor.height - 10 + 40 * (1 - handsProgress);
                ctx.save();
                ctx.globalAlpha = handsProgress;
                // Remove any shadow for hands
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = '#eab676';
                // Left hand
                ctx.beginPath();
                ctx.ellipse(monitor.x + 25, handY, 18, 16, -0.2, 0, Math.PI*2);
                ctx.fill();
                // Fingers (left)
                for (let f=0; f<4; f++) {
                    ctx.beginPath();
                    ctx.ellipse(monitor.x + 15 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                    ctx.fill();
                }
                // Right hand
                ctx.beginPath();
                ctx.ellipse(monitor.x + monitor.width - 25, handY, 18, 16, 0.2, 0, Math.PI*2);
                ctx.fill();
                // Fingers (right)
                for (let f=0; f<4; f++) {
                    ctx.beginPath();
                    ctx.ellipse(monitor.x + monitor.width - 35 + f*6, handY+12, 4, 10, 0, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }

            // Draw cat: sideways or back view
            ctx.save();
            ctx.translate(cat.x + cat.width / 2, cat.y + cat.height / 2);
            // Track last direction
            if (typeof cat.lastFacing === 'undefined') cat.lastFacing = 1;
            if (keys['ArrowLeft'] && !keys['ArrowRight']) cat.lastFacing = -1;
            else if (keys['ArrowRight'] && !keys['ArrowLeft']) cat.lastFacing = 1;
            ctx.scale(cat.lastFacing, 1);
            let walkCycle = 0;
            if (cat.isJumping) {
                walkCycle = Math.sin(Date.now() / 120) * 2;
            } else if (keys['ArrowLeft'] || keys['ArrowRight']) {
                walkCycle = Math.sin(Date.now() / 120) * 4;
            }

            // If in code mode, show back view with tip-tapping paws
            if (codeMode) {
                // --- BACK VIEW ---
                // Body (back, rounder)
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.ellipse(0, 8, 13, 11, 0, 0, Math.PI * 2);
                ctx.fill();
                // Head (back, round)
                ctx.beginPath();
                ctx.arc(0, -6, 9, 0, Math.PI * 2);
                ctx.fill();
                // Ears (back, on head)
                ctx.beginPath();
                ctx.moveTo(-6, -14);
                ctx.lineTo(-3, -22);
                ctx.lineTo(0, -10);
                ctx.moveTo(6, -14);
                ctx.lineTo(3, -22);
                ctx.lineTo(0, -10);
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 3;
                ctx.stroke();
                // Fedora (black hat)
                if (catWearsFedora) {
                    ctx.save();
                    // Brim
                    ctx.beginPath();
                    ctx.ellipse(0, -15, 14, 5, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#111';
                    ctx.globalAlpha = 0.95;
                    ctx.fill();

                    // Crown - more fedora-like with tapered shape and pinch
                    ctx.beginPath();
                    // Left side of crown
                    ctx.moveTo(-7, -15);
                    ctx.lineTo(-6, -25);
                    // Top with pinch/dent
                    ctx.lineTo(-2, -27);
                    ctx.lineTo(0, -26);
                    ctx.lineTo(2, -27);
                    // Right side
                    ctx.lineTo(6, -25);
                    ctx.lineTo(7, -15);
                    ctx.closePath();
                    ctx.fillStyle = '#111';
                    ctx.fill();

                    // Hat band
                    ctx.beginPath();
                    ctx.rect(-7, -21, 14, 3);
                    ctx.fillStyle = '#444';
                    ctx.fill();

                    // Hat band decoration (small accent)
                    ctx.beginPath();
                    ctx.moveTo(5, -19.5);
                    ctx.lineTo(7, -19.5);
                    ctx.lineTo(6, -21);
                    ctx.closePath();
                    ctx.fillStyle = '#777';
                    ctx.fill();

                    ctx.restore();
                }
                // Tail (back, up)
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(0, 18);
                ctx.bezierCurveTo(0, 32, 8, 38 + walkCycle, 0, 48 + walkCycle);
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();
                // Paws (tip-tapping)
                let tap = Math.abs(Math.sin(Date.now() / 80));
                let tap2 = Math.abs(Math.sin(Date.now() / 80 + 1));
                // Left paw
                ctx.save();
                ctx.translate(-6, 18 + tap * 3);
                ctx.rotate(-0.2 + tap * 0.2);
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                // Right paw
                ctx.save();
                ctx.translate(6, 18 + tap2 * 3);
                ctx.rotate(0.2 - tap2 * 0.2);
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.restore(); // Restore main cat transform after back view
            } else {
                // --- SIDEWAYS VIEW ---
                // Body (sideways oval)
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.ellipse(2, 6, 14, 7, Math.PI / 12, 0, Math.PI * 2);
                ctx.fill();
                // Head (sideways circle, slightly forward)
                ctx.beginPath();
                ctx.ellipse(16, -2, 7, 8, Math.PI / 16, 0, Math.PI * 2);
                ctx.fill();

                // Ears (sideways, lowered to sit on head)
                ctx.beginPath();
                ctx.moveTo(21, -4);
                ctx.lineTo(19, -12);
                ctx.lineTo(16, 2);
                ctx.moveTo(11, -4);
                ctx.lineTo(13, -12);
                ctx.lineTo(16, 2);
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 3;
                ctx.stroke();

                // --- Fedora (sideways hat, match back view style, lowered to cover ears) ---
                if (catWearsFedora) {
                    ctx.save();
                    // Flip hat for left/right facing
                    let hatOffsetX = cat.lastFacing === 1 ? 16 : 16;
                    let hatOffsetY = -4; // Lowered from -10 to -4 to cover ears
                    ctx.translate(hatOffsetX, hatOffsetY);
                    ctx.scale(cat.lastFacing, 1);

                    // Brim (sideways, match back view)
                    ctx.beginPath();
                    ctx.ellipse(0, -7, 14, 5, Math.PI / 16, 0, Math.PI * 2);
                    ctx.fillStyle = '#111';
                    ctx.globalAlpha = 0.95;
                    ctx.fill();

                    // Crown - more fedora-like with tapered shape and pinch
                    ctx.beginPath();
                    // Create crown with pinch (from side view)
                    ctx.moveTo(-7, -9);      // Bottom left
                    ctx.lineTo(-6, -17);     // Top left, tapered in
                    ctx.lineTo(-2, -19);     // First pinch point
                    ctx.lineTo(0, -18);      // Center dip
                    ctx.lineTo(2, -19);      // Second pinch point
                    ctx.lineTo(6, -17);      // Top right, tapered in
                    ctx.lineTo(7, -9);       // Bottom right
                    ctx.closePath();
                    ctx.fillStyle = '#111';
                    ctx.fill();

                    // Hat band (sideways, thin rectangle)
                    ctx.beginPath();
                    ctx.rect(-7, -13, 14, 3);
                    ctx.fillStyle = '#444';
                    ctx.fill();

                    // Hat band decoration (small accent)
                    ctx.beginPath();
                    ctx.moveTo(5, -11.5);
                    ctx.lineTo(7, -11.5);
                    ctx.lineTo(6, -13);
                    ctx.closePath();
                    ctx.fillStyle = '#777';
                    ctx.fill();

                    ctx.restore();
                }

                // Eye (single, side profile)
                ctx.beginPath();
                ctx.ellipse(19, -4, 1.5, 2, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(19, -4, 0.7, 1, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
                // Nose (side, pink)
                ctx.beginPath();
                ctx.ellipse(23, -1, 0.7, 1, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#eab';
                ctx.fill();
                // Tail (points up, cleanly attached to body)
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.bezierCurveTo(-18, -18 - walkCycle, -6, -38 - walkCycle, 0, -32 - walkCycle);
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();
                // Legs (sideways, move when walking)
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 4;
                // Back leg
                ctx.beginPath();
                ctx.moveTo(-2, 13);
                ctx.lineTo(-2 + walkCycle, 22 - walkCycle);
                ctx.stroke();
                // Front leg
                ctx.beginPath();
                ctx.moveTo(8, 13);
                ctx.lineTo(8 - walkCycle, 22 + walkCycle);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            ctx.restore();


            // Draw code particles and meow particles (no shadow)
            codeParticles.forEach(particle => {
                ctx.save();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.globalAlpha = particle.alpha;
                if (particle.isMeow) {
                    ctx.font = `bold ${particle.size}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeText(particle.text, particle.x, particle.y);
                    ctx.fillStyle = '#4ec9f0';
                    ctx.fillText(particle.text, particle.x, particle.y);
                } else {
                    ctx.font = `${particle.size}px monospace`;
                    // Use regex to split and keep delimiters, including whitespace
                    const words = particle.text.match(/(\s+|[a-zA-Z_][a-zA-Z0-9_]*|\d+|[^\s\w])/g) || [];
                    let xOffset = 10;
                    const letterSpacing = particle.size
                    words.forEach(word => {
                        let color = 'white';
                        if (word === 'console') color = 'lightgreen';
                        else if (word === 'log') color = particle.logColor;
                        else if (word === 'meow' || word === 'tuna' || word === 'yarn' || word === 'purr') color = 'magenta';
                        else if (word === 'cat' || word === 'Food' || word === 'wakeUp' || word === 'debug' || word === 'function' || word === 'return' || word === 'if' || word === 'let' || word === 'new') color = 'lightblue';
                        else if (['Slep'].includes(word)) color = 'orange';
                        else if (word === 'error') color = 'red';
                        ctx.fillStyle = color;
                        ctx.fillText(word, Math.round(particle.x + xOffset), particle.y);
                        let width = ctx.measureText(word).width;
                        // Always add spacing after each token
                        xOffset += width + letterSpacing;
                    });
                }
                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        let keys = {};
        let scoredKeys = {};
        let lastKeyPressTime = 1;
        let comboMultiplier = 1;
        const comboThreshold = 400; // ms
        const comboMax = 7;

        // For tip-tapping animation, track if user is typing
        let tipTapping = false;
        let tipTapTimeout;
    document.addEventListener('keydown', (e) => {
            // --- Coffee cup push mechanic ---
            if (e.code === 'Space') {
                for (let cup of coffeeCups) {
                    if (isCatNearCup(cup) && !cup.airborne) {
                        pushCoffeeCup(cup);
                        break;
                    }
                }
            }
            keys[e.key] = true;
            if (e.key === 'ArrowUp' && !cat.isJumping) {
                cat.velocityY = -10;
                cat.isJumping = true;
            }
            if (codeMode && e.key.match(/^[a-z]$/)) {
                generateCodeParticle();
                animateScore(1);
                tipTapping = true;
                clearTimeout(tipTapTimeout);
                tipTapTimeout = setTimeout(() => { tipTapping = false; }, 120);
            }
            // --- Meow feature: space bar during hands at monitor ---
            if (
                stealthState === 'hands' &&
                handsProgress === 1 &&
                e.code === 'Space'
            ) {
                // Create a floating 'meow' particle from the cat
                codeParticles.push({
                    x: cat.x + cat.width / 2,
                    y: cat.y,
                    text: 'meow',
                    consoleColor: 'green',
                    logColor: 'orange',
                    meowColor: 'lightblue',
                    size: 22,
                    speedX: (Math.random() - 0.5) * 1.2,
                    speedY: -2.5 - Math.random() * 1.5,
                    targetX: cat.x + cat.width / 2 + (Math.random() - 0.5) * 40,
                    targetY: cat.y - 60 - Math.random() * 30,
                    alpha: 1,
                    isMeow: true
                });
                // Start meow count if not started
                if (!meowTarget) {
                    meowTarget = 2 + Math.floor(Math.random() * 6); // 2-7
                    meowCount = 0;
                }
                meowCount++;
                // If reached target, trigger hands chase
                if (meowCount >= meowTarget) {
                    stealthState = 'handsChase';
                    handsChaseActive = false; // will init in update()
                }
            } else if (

                e.code === 'Space'
            ) {

                 codeParticles.push({
                    x: cat.x + cat.width / 2,
                    y: cat.y,
                    text: 'meow',
                    consoleColor: 'white',
                    logColor: 'white',
                    meowColor: 'lightblue',
                    size: 22,
                    speedX: (Math.random() - 0.5) * 1.2,
                    speedY: -2.5 - Math.random() * 1.5,
                    targetX: cat.x + cat.width / 2 + (Math.random() - 0.5) * 40,
                    targetY: cat.y - 60 - Math.random() * 30,
                    alpha: 1,
                    isMeow: true
                });
                // Start meow count if not started
                if (!meowTarget) {
                    meowTarget = 3 + Math.floor(Math.random() * 4); // 3-7
                    meowCount = 0;
                }
                meowCount++;
                // If reached target, trigger hands chase
                if (meowCount >= meowTarget) {


                    nextStealthEvent = Date.now()
                }
            }
        });

        function animateScore(points) {
            let startScore = score;
            let endScore = score + points;
            const animationDuration = .2;
            const startTime = performance.now();

            function updateScore(currentTime) {
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / animationDuration, 1);
                const animatedScore = Math.floor(startScore + (endScore - startScore) * progress);
                gitAdditions.textContent = animatedScore;
                updateGitCubeColor(animatedScore);
                if (progress < 1) {
                    requestAnimationFrame(updateScore);
                } else {
                    score = endScore;
                    gitAdditions.textContent = score;
                    updateGitCubeColor(score);
                }
            }

            requestAnimationFrame(updateScore);
            // Track for git graph
            if (gameStarted && additionsHistory.length < 32) {
                additionsHistory.push(score + points);
            }
        }

        function endGame() {
            gameStarted = false;
            clearInterval(timerInterval);
            showTimer(false);
            gameOverScreen.style.display = 'flex';
            gameOverScreen.setAttribute('data-reason', 'petted');
            document.getElementById('gameOverMessage').textContent = 'you were petted.';
            finalScores.innerHTML = `<span style='color:#2ea043;'>+${score} additions</span> &nbsp; <span style='color:#f85149;'>-${deletionsScore} deletions</span>`;
            drawGitGraph();
            // --- Store result and update grid ---
            if (gitGraphResults.length < maxGames) {
                gitGraphResults.push({ score, deletions: deletionsScore });
            }
            updateGitGraphGrid();
            // --- If 7 games played, show report ---
            if (gitGraphResults.length === maxGames) {
                setTimeout(showReport, 1200); // Give a moment for last game over
            }
        }

        function showReport() {
            // Hide start button, show report
            startButton.style.display = 'none';
            reportScreen.style.display = 'block';
            scoreboard.style.display = 'none'; // Hide scoreboard on report screen
            // Calculate total additions
            let total = gitGraphResults.reduce((sum, g) => sum + Math.max(0, g.score - g.deletions), 0);
            let rank = getRank(total);
            let rankColor = {
                'kode kitten': '#888',
                'junior dev': '#1e90ff',
                'script kitty': '#f7c325',
                'senior dev': '#a259e6',
                'grey cat hacker': '#2ea043',
                'master black cat hacker': '#000'
            }[rank] || '#fff';
            let rankText = `<span style='font-size:2em; color:${rankColor}; font-weight:bold;'>${rank.replace(/\b\w/g, l => l.toUpperCase())}</span>`;
            let details = gitGraphResults.map((g, i) => `<div style='font-size:1.1em; margin:4px 0;'>Game ${i+1}: <span style='color:#2ea043;'>+${g.score}</span> <span style='color:#f85149;'>-${g.deletions}</span> = <b>${Math.max(0, g.score-g.deletions)}</b></div>`).join('');
            reportScreen.innerHTML = `<h2>7 Games Complete!</h2><div style='margin:12px 0 18px 0;'>Total Additions: <span style='color:#2ea043; font-size:1.3em;'>${total}</span></div>${details}<div style='margin:18px 0 8px 0;'>Rank:</div>${rankText}<div style='margin-top:18px;'><button id='resetSeriesBtn' style='font-size:1em; padding:8px 24px; border-radius:8px; border:none; background:#2ea043; color:white; cursor:pointer;'>Play Again</button></div>`;
            // Reset button
            setTimeout(() => {
                document.getElementById('resetSeriesBtn').onclick = () => {
                    gitGraphResults = [];
                    updateGitGraphGrid();
                    reportScreen.style.display = 'none';
                    startButton.style.display = 'inline-block';
                };
            }, 100);
        }

        function drawGitGraph() {
            const ctx = gitGraph.getContext('2d');
            ctx.clearRect(0, 0, gitGraph.width, gitGraph.height);
            // Color the square by (additions - deletions)
            const net = Math.max(0, score - deletionsScore);
            const maxScore = 1000;
            const percent = Math.min(net / maxScore, 1);
            // interpolate from grey (#888) to green (#2ea043)
            function lerp(a, b, t) { return a + (b - a) * t; }
            function hexToRgb(hex) {
                hex = hex.replace('#', '');
                if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                const num = parseInt(hex, 16);
                return [num >> 16, (num >> 8) & 0xff, num & 0xff];
            }
            function rgbToHex([r, g, b]) {
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }
            const grey = hexToRgb('#888');
            const green = hexToRgb('#2ea043');
            const color = [
                Math.round(lerp(grey[0], green[0], percent)),
                Math.round(lerp(grey[1], green[1], percent)),
                Math.round(lerp(grey[2], green[2], percent))
            ];
            ctx.fillStyle = rgbToHex(color);
            ctx.fillRect(0, 0, gitGraph.width, gitGraph.height);
            ctx.strokeStyle = '#2ea043';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, gitGraph.width-2, gitGraph.height-2);
        }

        function updateGitCubeColor() {
            // Color by (additions - deletions)
            const net = Math.max(0, score - deletionsScore);
            const maxScore = 1000;
            const percent = Math.min(net / maxScore, 1);
            function lerp(a, b, t) { return a + (b - a) * t; }
            function hexToRgb(hex) {
                hex = hex.replace('#', '');
                if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                const num = parseInt(hex, 16);
                return [num >> 16, (num >> 8) & 0xff, num & 0xff];
            }
            function rgbToHex([r, g, b]) {
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }
            const grey = hexToRgb('#888');
            const green = hexToRgb('#2ea043');
            const color = [
                Math.round(lerp(grey[0], green[0], percent)),
                Math.round(lerp(grey[1], green[1], percent)),
                Math.round(lerp(grey[2], green[2], percent))
            ];
            gitCube.style.background = rgbToHex(color);
        }

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // --- Prevent multiple game loops from stacking ---
        let gameLoopRunning = false;
        function gameLoop() {
            if (!gameLoopRunning) return;
            // --- Multi-key scoring logic with combo ---
    if (codeMode) {
        const now = Date.now();
        Object.keys(keys).forEach(key => {
            if (keys[key] && key.match(/^[a-z]$/) && !scoredKeys[key]) {
                // Combo logic
                if (now - lastKeyPressTime < comboThreshold) {
                    comboMultiplier = Math.min(comboMultiplier + 1, comboMax);
                } else {
                    comboMultiplier = 1;
                }
                lastKeyPressTime = now;
                generateCodeParticle();
                animateScore(comboMultiplier);
                scoredKeys[key] = true;
                tipTapping = true;
                clearTimeout(tipTapTimeout);
                tipTapTimeout = setTimeout(() => { tipTapping = false; }, 120);
            }
        });
    }
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

    tutorialButton.addEventListener('click', () => {
        tutorialScreen.style.display = 'flex';
        reportScreen.style.display = 'block';
        let tutorialText = `<span style='font-size:1em; color:white; font-weight:bold;'> Press SPACE to meow and push coffee cups || press -> <- to move left and right and ^ to jump, Spam any letter key when infront of the computer to code!</span>`;
        reportScreen.innerHTML = `<h2>cat -s tutorial.txt</h2><div>${tutorialText}</div><div style='margin-top:18px;'><button id='resetSeriesBtn' style='font-size:1em; padding:8px 24px; border-radius:8px; border:none; background:#2ea043; color:white; cursor:pointer;'>Reset Game</button></div><div><p><button id='closeBtn' style='font-size:1em; padding:8px 24px; border-radius:8px; border:none; background:#2ea043; color:white; cursor:pointer;'>Close</button></div>`;
        // Reset button
        setTimeout(() => {
            document.getElementById('resetSeriesBtn').onclick = () => {
                gitGraphResults = [];
                updateGitGraphGrid();
                reportScreen.style.display = 'none';
                startButton.style.display = 'inline-block';
            };
        }, 100);
        setTimeout(() => {
            document.getElementById('closeBtn').onclick = () => {
                reportScreen.style.display = 'none';
                startButton.style.display = 'inline-block';
            };
        }, 100);
    }
     );

    startButton.addEventListener('click', () => {
        // Spawn coffee cups for this round
        spawnRandomShelves(); // Spawn random shelves each round
        spawnCoffeeCups();
        if (gitGraphResults.length === maxGames) return; // Don't start if series complete
        // --- FULL GAME RESET ---
        chaseSuccessCount = 0;
        gameStarted = true;
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        scoreboard.style.display = 'block'; // Show scoreboard only during game
        score = 0;
        deletionsScore = 0;
        gitAdditions.textContent = 0;
        gitDeletions.textContent = 0;
        additionsHistory = [];
        codeParticles = [];
        stealthState = 'idle';
        stealthTimer = 0;
        nextStealthEvent = Date.now() + 3000 + Math.random() * 5000;
        doorOpenProgress = 0;
        footprintsProgress = 0;
        handsProgress = 0;
        handsHoldTimer = 0;
        footstepsBackProgress = 0;
        doorCloseProgress = 0;
        lastStealthFrame = Date.now();
        lastHandsSecond = null;
        // Reset cat position and state
        cat.x = 50;
        cat.y = 500;
        cat.velocityY = 0;
        cat.isJumping = false;
        codeMode = false;
        // Clear keys
        keys = {};
        // --- Reset and start timer for the round ---
        round = 1;
        currentTime = baseTime;
        startTimer();
        // --- Start game loop only if not already running ---
        if (!gameLoopRunning) {
            gameLoopRunning = true;
            requestAnimationFrame(gameLoop);
        }
    });

    const fedoraCheckbox = document.getElementById('fedoraCheckbox');
    fedoraCheckbox.addEventListener('change', (event) => {
        catWearsFedora = event.target.checked;
    });

        restartButton.addEventListener('click', () => {
            // Show the start screen and hide the game over screen, reset game state
            startScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            scoreboard.style.display = 'none'; // Hide scoreboard on start screen
            updateGitGraphGrid();
            // Stop the game loop if running
            gameLoopRunning = false;
            // Optionally reset cat position and other variables if needed
        });

    tutorialButton.addEventListener('click', () => {
        tutorialScreen.style.display = 'flex';
        reportScreen.style.display = 'block';
        let tutorialText = `<span style='font-size:1em; color:white; font-weight:bold;'> Press SPACE to meow and push coffee cups || press -> <- to move left and right and ^ to jump, Spam any letter key when infront of the computer to code!</span>`;
        reportScreen.innerHTML = `<h2>cat -s tutorial.txt</h2><div>${tutorialText}</div><div style='margin-top:18px;'><button id='resetSeriesBtn' style='font-size:1em; padding:8px 24px; border-radius:8px; border:none; background:#2ea043; color:white; cursor:pointer;'>Reset Game</button></div><div><p><button id='closeBtn' style='font-size:1em; padding:8px 24px; border-radius:8px; border:none; background:#2ea043; color:white; cursor:pointer;'>Close</button></div>`;
        // Reset button
        setTimeout(() => {
            document.getElementById('resetSeriesBtn').onclick = () => {
                gitGraphResults = [];
                updateGitGraphGrid();
                reportScreen.style.display = 'none';
                startButton.style.display = 'inline-block';
            };
        }, 100);
        setTimeout(() => {
            document.getElementById('closeBtn').onclick = () => {
                reportScreen.style.display = 'none';
                startButton.style.display = 'inline-block';
            };
        }, 100);
    }
     );

    function showReport() {
        // Hide start button, show report
        startButton.style.display = 'none';
        reportScreen.style.display = 'block';
        scoreboard.style.display = 'none'; // Hide scoreboard on report screen
        // Calculate total additions
        let total = gitGraphResults.reduce((sum, g) => sum + Math.max(0, g.score - g.deletions), 0);
        let rank = getRank(total);
        let rankColor = {
            'kode kitten': '#888',
            'junior dev': '#1e90ff',
            'script kitty': '#f7c325',
            'senior dev': '#a259e6',
            'grey cat hacker': '#2ea043',
            'master black cat hacker': '#000'
        }[rank] || '#fff';
        let rankText = `<span style='font-size:2em; color:${rankColor}; font-weight:bold;'>${rank.replace(/\b\w/g, l => l.toUpperCase())}</span>`;
        let details = gitGraphResults.map((g, i) => `<div style='font-size:1.1em; margin:4px 0;'>Game ${i+1}: <span style='color:#2ea043;'>+${g.score}</span> <span style='color:#f85149;'>-${g.deletions}</span> = <b>${Math.max(0, g.score-g.deletions)}</b></div>`).join('');
        reportScreen.innerHTML = `<h2>7 Games Complete!</h2><div style='margin:12px 0 18px 0;'>Total Additions: <span style='color:#2ea043; font-size:1.3em;'>${total}</span></div>${details}<div style='margin:18px 0 8px 0;'>Rank:</div>${rankText}<div style='margin-top:18px;'><button id='resetSeriesBtn' style='font-size:1em; padding:8px 24px; border-radius:8px; border:none; background:#2ea043; color:white; cursor:pointer;'>Play Again</button></div>`;
        // Reset button
        setTimeout(() => {
            document.getElementById('resetSeriesBtn').onclick = () => {
                gitGraphResults = [];
                updateGitGraphGrid();
                reportScreen.style.display = 'none';
                startButton.style.display = 'inline-block';
            };
        }, 100);
    }

    // On load, always update grid and hide scoreboard
    updateGitGraphGrid();
    scoreboard.style.display = 'none';
    // Stop any game loop on page load
    gameLoopRunning = false;
</script>
</body>
</html>

